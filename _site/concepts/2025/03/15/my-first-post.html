<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Clock Domain Crossing - Slug Silicon</title>
<meta name="description" content="What is Clock Domain Crossing?  Solutions    Flip-Flop Synchronizers   Binary and Gray Encoding   FIFO Example  What is Clock Domain Crossing?  Clock Domain Crossing (CDC) occurs when data transfers between different clock domains that may differ in frequency or phase. In a multi-clock system, data is first updated synchronously with the edge of the source clock, then it must be safely captured and updated synchronously in the destination clock domain. While simple in theory, there are challenging aspects to consider when attempting to maintain the reliability of data transfer. Signals that originate from one clock domain may not meet the setup and hold time required by the destination clock. Incorrect handling of CDC will lead to timing violations, metastability, data corruption, and other unpredictable behaviors in digital systems.  Though timing issues are a concern when implementing CDC, there are many performance benefits to using multiple clock domains in a digital design.    Decrease the clock rate for some parts of the design while using a higher clock rate when necessary in order to improve power efficiency.   Data throughput can be improved for a high-speed communication protocol while internal interactions operate at a lower clock rate.   There is more design flexibility when utilizing multiple clocks in a single design.   Improves clock tree synthesis results for skew and jitter when there are multiple localized clocks rather than one global clock.   Clock Domain Crossing Solutions  To achieve reliable data transfer, various CDC techniques are used. Some strategies include flip-flop synchronizers, handshake protocols, and FIFO-based solutions. FIFO buffers are particularly useful when handling bulk data transfers across clock domains, which we will explore in detail.  Flip-Flop Synchronizers  Among the most simple ways to solve CDC timing issues is through a flip-flop synchronizer. This uses (usually) two sequential flip-flops triggered by the destination clock. The flip-flop synchronizer solution will allow enough time for a signal to settle and avoid metastability.  module ff_synchronizer (     input  [0:0] clk_dest_i,      // destination clock      input  [0:0] rst_dest_i,      // destination reset     input  [0:0] async_signal_i,  // async input signal     output [0:0] sync_signal_o    // sync output signal );     logic [0:0] stage1_l;  // first stage      logic [0:0] stage2_l;  // second stage       // two sequential flip-flops     always_ff @(posedge clk_dest) begin         if (rst_dest_i) begin             stage1_l &lt;= 1&#39;b0;             stage2_l &lt;= 1&#39;b0;                    end         else begin             stage1_l &lt;= async_signal_i;             stage2_l &lt;= stage1_l;         end     end      assign sync_signal_o = stage2_l;  endmodule   Binary and Gray Encoding  Transferring a data bus is more challenging as binary encoding is unsafe due to the possibility of multiple bits changing in one increment or decrement. This may cause data corruption from some bits updating on the first destination clock synchronizer while other bits remain in their previous state. This is a massive problem for digital design, for example, think about a state machine encoding. If state changes and is passed to the destination clock, corrupted bits may cause the state encoding to point to a nonexistent state.  Instead, Gray code is used because only one bit changes per increment or decrement, making it safer for synchronization as it will either stay in the form of the previous data or update to the correct current data.  module bin_to_gray   #(parameter width_p = 5)   (input [width_p - 1 : 0] bin_i   ,output [width_p - 1 : 0] gray_o);     genvar i;     generate       for(i = width_p -1; i &gt; 0; i = i - 1) begin         assign gray_o[i - 1] = bin_i[i] ^ bin_i[i - 1];       end     endgenerate      assign gray_o[width_p-1] = bin_i[width_p-1];  endmodule   module gray_to_bin   #(parameter width_p = 5)    (input [width_p - 1 : 0] gray_i     ,output [width_p - 1 : 0] bin_o);    genvar i;   generate     for(i = 0; i &lt; width_p; i++) begin       assign bin_o[i] = ^(gray_i &gt;&gt; i);     end   endgenerate  endmodule   FIFO Example">


  <meta name="author" content="Annabella">
  
  <meta property="article:author" content="Annabella">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Slug Silicon">
<meta property="og:title" content="Clock Domain Crossing">
<meta property="og:url" content="http://localhost:4000/concepts/2025/03/15/my-first-post.html">


  <meta property="og:description" content="What is Clock Domain Crossing?  Solutions    Flip-Flop Synchronizers   Binary and Gray Encoding   FIFO Example  What is Clock Domain Crossing?  Clock Domain Crossing (CDC) occurs when data transfers between different clock domains that may differ in frequency or phase. In a multi-clock system, data is first updated synchronously with the edge of the source clock, then it must be safely captured and updated synchronously in the destination clock domain. While simple in theory, there are challenging aspects to consider when attempting to maintain the reliability of data transfer. Signals that originate from one clock domain may not meet the setup and hold time required by the destination clock. Incorrect handling of CDC will lead to timing violations, metastability, data corruption, and other unpredictable behaviors in digital systems.  Though timing issues are a concern when implementing CDC, there are many performance benefits to using multiple clock domains in a digital design.    Decrease the clock rate for some parts of the design while using a higher clock rate when necessary in order to improve power efficiency.   Data throughput can be improved for a high-speed communication protocol while internal interactions operate at a lower clock rate.   There is more design flexibility when utilizing multiple clocks in a single design.   Improves clock tree synthesis results for skew and jitter when there are multiple localized clocks rather than one global clock.   Clock Domain Crossing Solutions  To achieve reliable data transfer, various CDC techniques are used. Some strategies include flip-flop synchronizers, handshake protocols, and FIFO-based solutions. FIFO buffers are particularly useful when handling bulk data transfers across clock domains, which we will explore in detail.  Flip-Flop Synchronizers  Among the most simple ways to solve CDC timing issues is through a flip-flop synchronizer. This uses (usually) two sequential flip-flops triggered by the destination clock. The flip-flop synchronizer solution will allow enough time for a signal to settle and avoid metastability.  module ff_synchronizer (     input  [0:0] clk_dest_i,      // destination clock      input  [0:0] rst_dest_i,      // destination reset     input  [0:0] async_signal_i,  // async input signal     output [0:0] sync_signal_o    // sync output signal );     logic [0:0] stage1_l;  // first stage      logic [0:0] stage2_l;  // second stage       // two sequential flip-flops     always_ff @(posedge clk_dest) begin         if (rst_dest_i) begin             stage1_l &lt;= 1&#39;b0;             stage2_l &lt;= 1&#39;b0;                    end         else begin             stage1_l &lt;= async_signal_i;             stage2_l &lt;= stage1_l;         end     end      assign sync_signal_o = stage2_l;  endmodule   Binary and Gray Encoding  Transferring a data bus is more challenging as binary encoding is unsafe due to the possibility of multiple bits changing in one increment or decrement. This may cause data corruption from some bits updating on the first destination clock synchronizer while other bits remain in their previous state. This is a massive problem for digital design, for example, think about a state machine encoding. If state changes and is passed to the destination clock, corrupted bits may cause the state encoding to point to a nonexistent state.  Instead, Gray code is used because only one bit changes per increment or decrement, making it safer for synchronization as it will either stay in the form of the previous data or update to the correct current data.  module bin_to_gray   #(parameter width_p = 5)   (input [width_p - 1 : 0] bin_i   ,output [width_p - 1 : 0] gray_o);     genvar i;     generate       for(i = width_p -1; i &gt; 0; i = i - 1) begin         assign gray_o[i - 1] = bin_i[i] ^ bin_i[i - 1];       end     endgenerate      assign gray_o[width_p-1] = bin_i[width_p-1];  endmodule   module gray_to_bin   #(parameter width_p = 5)    (input [width_p - 1 : 0] gray_i     ,output [width_p - 1 : 0] bin_o);    genvar i;   generate     for(i = 0; i &lt; width_p; i++) begin       assign bin_o[i] = ^(gray_i &gt;&gt; i);     end   endgenerate  endmodule   FIFO Example">







  <meta property="article:published_time" content="2025-03-15T00:00:00-07:00">






<link rel="canonical" href="http://localhost:4000/concepts/2025/03/15/my-first-post.html">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Slug Silicon Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script type="text/javascript">
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Slug Silicon
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/"
                
                
              >Home</a>
            </li><li class="masthead__menu-item">
              <a
                href="/concepts/"
                
                
              >Concepts & Tutorials </a>
            </li><li class="masthead__menu-item">
              <a
                href="/projects/"
                
                
              >Projects</a>
            </li><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person" class="h-card">

  
    <div class="author__avatar">
      <a href="http://localhost:4000/">
        <img src="/assets/images/avatar.png" alt="Annabella" itemprop="image" class="u-photo">
      </a>
    </div>
  

  <div class="author__content">
    <h3 class="author__name p-name" itemprop="name">
      <a class="u-url" rel="me" href="http://localhost:4000/" itemprop="url">Annabella</a>
    </h3>
    
      <div class="author__bio p-note" itemprop="description">
        <p>Computer Engineering @ UCSC</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      

      
        
          
            <li><a href="https://github.com/anbellumToo" rel="nofollow noopener noreferrer me" itemprop="sameAs"><i class="fab fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer me">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Clock Domain Crossing">
    <meta itemprop="description" content="What is Clock Domain Crossing?Solutions  Flip-Flop Synchronizers  Binary and Gray EncodingFIFO ExampleWhat is Clock Domain Crossing?Clock Domain Crossing (CDC) occurs when data transfers between different clock domains that may differ in frequency or phase. In a multi-clock system, data is first updated synchronously with the edge of the source clock, then it must be safely captured and updated synchronously in the destination clock domain. While simple in theory, there are challenging aspects to consider when attempting to maintain the reliability of data transfer. Signals that originate from one clock domain may not meet the setup and hold time required by the destination clock. Incorrect handling of CDC will lead to timing violations, metastability, data corruption, and other unpredictable behaviors in digital systems.Though timing issues are a concern when implementing CDC, there are many performance benefits to using multiple clock domains in a digital design.  Decrease the clock rate for some parts of the design while using a higher clock rate when necessary in order to improve power efficiency.  Data throughput can be improved for a high-speed communication protocol while internal interactions operate at a lower clock rate.  There is more design flexibility when utilizing multiple clocks in a single design.  Improves clock tree synthesis results for skew and jitter when there are multiple localized clocks rather than one global clock.Clock Domain Crossing SolutionsTo achieve reliable data transfer, various CDC techniques are used. Some strategies include flip-flop synchronizers, handshake protocols, and FIFO-based solutions. FIFO buffers are particularly useful when handling bulk data transfers across clock domains, which we will explore in detail.Flip-Flop SynchronizersAmong the most simple ways to solve CDC timing issues is through a flip-flop synchronizer. This uses (usually) two sequential flip-flops triggered by the destination clock. The flip-flop synchronizer solution will allow enough time for a signal to settle and avoid metastability.module ff_synchronizer (    input  [0:0] clk_dest_i,      // destination clock     input  [0:0] rst_dest_i,      // destination reset    input  [0:0] async_signal_i,  // async input signal    output [0:0] sync_signal_o    // sync output signal);    logic [0:0] stage1_l;  // first stage     logic [0:0] stage2_l;  // second stage     // two sequential flip-flops    always_ff @(posedge clk_dest) begin        if (rst_dest_i) begin            stage1_l &lt;= 1&#39;b0;            stage2_l &lt;= 1&#39;b0;                   end        else begin            stage1_l &lt;= async_signal_i;            stage2_l &lt;= stage1_l;        end    end    assign sync_signal_o = stage2_l;endmoduleBinary and Gray EncodingTransferring a data bus is more challenging as binary encoding is unsafe due to the possibility of multiple bits changing in one increment or decrement. This may cause data corruption from some bits updating on the first destination clock synchronizer while other bits remain in their previous state. This is a massive problem for digital design, for example, think about a state machine encoding. If state changes and is passed to the destination clock, corrupted bits may cause the state encoding to point to a nonexistent state.Instead, Gray code is used because only one bit changes per increment or decrement, making it safer for synchronization as it will either stay in the form of the previous data or update to the correct current data.module bin_to_gray  #(parameter width_p = 5)  (input [width_p - 1 : 0] bin_i  ,output [width_p - 1 : 0] gray_o);   genvar i;    generate      for(i = width_p -1; i &gt; 0; i = i - 1) begin        assign gray_o[i - 1] = bin_i[i] ^ bin_i[i - 1];      end    endgenerate    assign gray_o[width_p-1] = bin_i[width_p-1];endmodulemodule gray_to_bin  #(parameter width_p = 5)   (input [width_p - 1 : 0] gray_i    ,output [width_p - 1 : 0] bin_o);  genvar i;  generate    for(i = 0; i &lt; width_p; i++) begin      assign bin_o[i] = ^(gray_i &gt;&gt; i);    end  endgenerateendmoduleFIFO Example">
    <meta itemprop="datePublished" content="2025-03-15T00:00:00-07:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="http://localhost:4000/concepts/2025/03/15/my-first-post.html" itemprop="url">Clock Domain Crossing
</a>
          </h1>
          


        </header>
      

      <section class="page__content" itemprop="text">
        
        <p><a href="#what-is-clock-domain-crossing">What is Clock Domain Crossing?</a></p>

<p><a href="#clock-domain-crossing-solutions">Solutions</a></p>
<ul>
  <li><a href="#flip-flop-synchronizers">Flip-Flop Synchronizers</a></li>
  <li><a href="#binary-and-gray-encoding">Binary and Gray Encoding</a></li>
</ul>

<p><a href="#fifo-example">FIFO Example</a></p>

<h2 id="what-is-clock-domain-crossing">What is Clock Domain Crossing?</h2>

<p>Clock Domain Crossing (CDC) occurs when data transfers between different clock domains that may differ in frequency or phase. In a multi-clock system, data is first updated synchronously with the edge of the source clock, then it must be safely captured and updated synchronously in the destination clock domain. While simple in theory, there are challenging aspects to consider when attempting to maintain the reliability of data transfer. Signals that originate from one clock domain may not meet the setup and hold time required by the destination clock. Incorrect handling of CDC will lead to timing violations, metastability, data corruption, and other unpredictable behaviors in digital systems.</p>

<p>Though timing issues are a concern when implementing CDC, there are many performance benefits to using multiple clock domains in a digital design.</p>
<ul>
  <li>Decrease the clock rate for some parts of the design while using a higher clock rate when necessary in order to improve power efficiency.</li>
  <li>Data throughput can be improved for a high-speed communication protocol while internal interactions operate at a lower clock rate.</li>
  <li>There is more design flexibility when utilizing multiple clocks in a single design.</li>
  <li>Improves clock tree synthesis results for skew and jitter when there are multiple localized clocks rather than one global clock.</li>
</ul>

<h2 id="clock-domain-crossing-solutions">Clock Domain Crossing Solutions</h2>

<p>To achieve reliable data transfer, various CDC techniques are used. Some strategies include flip-flop synchronizers, handshake protocols, and FIFO-based solutions. FIFO buffers are particularly useful when handling bulk data transfers across clock domains, which we will explore in detail.</p>

<h4 id="flip-flop-synchronizers">Flip-Flop Synchronizers</h4>

<p>Among the most simple ways to solve CDC timing issues is through a flip-flop synchronizer. This uses (usually) two sequential flip-flops triggered by the destination clock. The flip-flop synchronizer solution will allow enough time for a signal to settle and avoid metastability.</p>

<pre><code class="language-Systemverilog">module ff_synchronizer (
    input  [0:0] clk_dest_i,      // destination clock 
    input  [0:0] rst_dest_i,      // destination reset
    input  [0:0] async_signal_i,  // async input signal
    output [0:0] sync_signal_o    // sync output signal
);
    logic [0:0] stage1_l;  // first stage 
    logic [0:0] stage2_l;  // second stage 

    // two sequential flip-flops
    always_ff @(posedge clk_dest) begin
        if (rst_dest_i) begin
            stage1_l &lt;= 1'b0;
            stage2_l &lt;= 1'b0;           
        end
        else begin
            stage1_l &lt;= async_signal_i;
            stage2_l &lt;= stage1_l;
        end
    end

    assign sync_signal_o = stage2_l;

endmodule
</code></pre>

<h4 id="binary-and-gray-encoding">Binary and Gray Encoding</h4>

<p>Transferring a data bus is more challenging as binary encoding is unsafe due to the possibility of multiple bits changing in one increment or decrement. This may cause data corruption from some bits updating on the first destination clock synchronizer while other bits remain in their previous state. This is a massive problem for digital design, for example, think about a state machine encoding. If state changes and is passed to the destination clock, corrupted bits may cause the state encoding to point to a nonexistent state.</p>

<p>Instead, Gray code is used because only one bit changes per increment or decrement, making it safer for synchronization as it will either stay in the form of the previous data or update to the correct current data.</p>

<pre><code class="language-Systemverilog">module bin_to_gray
  #(parameter width_p = 5)
  (input [width_p - 1 : 0] bin_i
  ,output [width_p - 1 : 0] gray_o);

   genvar i;
    generate
      for(i = width_p -1; i &gt; 0; i = i - 1) begin
        assign gray_o[i - 1] = bin_i[i] ^ bin_i[i - 1];
      end
    endgenerate

    assign gray_o[width_p-1] = bin_i[width_p-1];

endmodule
</code></pre>

<pre><code class="language-Systemverilog">module gray_to_bin
  #(parameter width_p = 5)
   (input [width_p - 1 : 0] gray_i
    ,output [width_p - 1 : 0] bin_o);

  genvar i;
  generate
    for(i = 0; i &lt; width_p; i++) begin
      assign bin_o[i] = ^(gray_i &gt;&gt; i);
    end
  endgenerate

endmodule
</code></pre>

<h2 id="fifo-example">FIFO Example</h2>

        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2025-03-15T00:00:00-07:00">March 15, 2025</time></p>

      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://github.com/anbellumToo" rel="nofollow noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/annabella-newton/" rel="nofollow noopener noreferrer"><i class="fab fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 <a href="http://localhost:4000">Slug Silicon</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>






  </body>
</html>
