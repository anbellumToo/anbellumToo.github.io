<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Clock Domain Crossing - Slug Silicon</title>
<meta name="description" content="What is Clock Domain Crossing?  Solutions    Flip-Flop Synchronizers   Binary and Gray Encoding   FIFO Example  What is Clock Domain Crossing?  Clock Domain Crossing (CDC) occurs when data transfers between different clock domains that may differ in frequency or phase. In a multi-clock system, data is first updated synchronously with the edge of the source clock, then it must be safely captured and updated synchronously in the destination clock domain. While simple in theory, there are challenging aspects to consider when attempting to maintain the reliability of data transfer. Signals that originate from one clock domain may not meet the setup and hold time required by the destination clock. Incorrect handling of CDC will lead to timing violations, metastability, data corruption, and other unpredictable behaviors in digital systems.  Though timing issues are a concern when implementing CDC, there are many performance benefits to using multiple clock domains in a digital design.    Decrease the clock rate for some parts of the design while using a higher clock rate when necessary in order to improve power efficiency.   Data throughput can be improved for a high-speed communication protocol while internal interactions operate at a lower clock rate.   There is more design flexibility when utilizing multiple clocks in a single design.   Improves clock tree synthesis results for skew and jitter when there are multiple localized clocks rather than one global clock.   Clock Domain Crossing Solutions  To achieve reliable data transfer, various CDC techniques are used. Some strategies include flip-flop synchronizers, handshake protocols, and FIFO-based solutions. FIFO buffers are particularly useful when handling bulk data transfers across clock domains, which we will explore in detail.  Flip-Flop Synchronizers  Among the most simple ways to solve CDC timing issues is through a flip-flop synchronizer. This uses (usually) two sequential flip-flops triggered by the destination clock. The flip-flop synchronizer solution will allow enough time for a signal to settle and avoid metastability.  module ff_synchronizer (     input  [0:0] clk_dest_i,      // destination clock      input  [0:0] rst_dest_i,      // destination reset     input  [0:0] async_signal_i,  // async input signal     output [0:0] sync_signal_o    // sync output signal );     logic [0:0] stage1_l;  // first stage      logic [0:0] stage2_l;  // second stage       // two sequential flip-flops     always_ff @(posedge clk_dest) begin         if (rst_dest_i) begin             stage1_l &lt;= 1&#39;b0;             stage2_l &lt;= 1&#39;b0;                    end         else begin             stage1_l &lt;= async_signal_i;             stage2_l &lt;= stage1_l;         end     end      assign sync_signal_o = stage2_l;  endmodule   Binary and Gray Encoding  Transferring a data bus is more challenging as binary encoding is unsafe due to the possibility of multiple bits changing in one increment or decrement. This may cause data corruption from some bits updating on the first destination clock synchronizer while other bits remain in their previous state. This is a massive problem for digital design, for example, think about a state machine encoding. If state changes and is passed to the destination clock, corrupted bits may cause the state encoding to point to a nonexistent state.  Instead, Gray code is used because only one bit changes per increment or decrement, making it safer for synchronization as it will either stay in the form of the previous data or update to the correct current data.  module bin_to_gray   #(parameter width_p = 5)   (input [width_p - 1 : 0] bin_i   ,output [width_p - 1 : 0] gray_o);     genvar i;     generate       for(i = width_p -1; i &gt; 0; i = i - 1) begin         assign gray_o[i - 1] = bin_i[i] ^ bin_i[i - 1];       end     endgenerate      assign gray_o[width_p-1] = bin_i[width_p-1];  endmodule   module gray_to_bin   #(parameter width_p = 5)    (input [width_p - 1 : 0] gray_i     ,output [width_p - 1 : 0] bin_o);    genvar i;   generate     for(i = 0; i &lt; width_p; i++) begin       assign bin_o[i] = ^(gray_i &gt;&gt; i);     end   endgenerate  endmodule   FIFO Example  With the previous tools, we can implement a CDC fifo that is capable of transfering bulk data without the threat of data corruption issues. In order to create the CDC FIFO, we must initialize a RAM interface that will read data synchronized to the producer clock and write data synchronized to the consumer clock.  module ram_1r1w_sync   #(parameter [31:0] width_p = 8   ,parameter [31:0] depth_p = 512   ,parameter string filename_p = &quot;memory_init_file.bin&quot;)   (input [0:0] pclk_i   ,input [0:0] cclk_i   ,input [0:0] preset_i   ,input [0:0] creset_i    ,input [0:0] wr_valid_i   ,input [width_p-1:0] wr_data_i   ,input [$clog2(depth_p) - 1 : 0] wr_addr_i    ,input [0:0] rd_valid_i   ,input [$clog2(depth_p) - 1 : 0] rd_addr_i   ,output [width_p-1:0] rd_data_o);    logic [width_p-1:0] ram [depth_p-1:0];     initial begin       for (int i = 0; i &lt; depth_p; i++) begin         ram[i] = &#39;0;       end    end     logic [width_p-1:0] rd_data_l;     always @(posedge pclk_i) begin       if(preset_i) begin          rd_data_l &lt;= &#39;0;       end        else if(rd_valid_i) begin           rd_data_l &lt;= ram[rd_addr_i];       end    end     always @(posedge cclk_i) begin       if(creset_i) begin          ram[wr_addr_i] &lt;= ram[wr_addr_i];       end        else if(wr_valid_i) begin           ram[wr_addr_i] &lt;= wr_data_i;       end    end     assign rd_data_o = rd_data_l;  endmodule   Now we implement the CDC FIFO by connecting the synchronizers, gray encoding, and the two clock port RAM module. We use the RAM module to transfer data between the two clock domains safely. Within the FIFO implementation, the read and write addresses must be transferred between clock domains in order to facilitate the logic for the ready valid handshakes between interfaces.  module fifo_1r1w_cdc  #(parameter [31:0] width_p = 32   ,parameter [31:0] depth_log2_p = 8   )    // the &quot;c&quot; for consumer, and &quot;p&quot; for producer interfaces.    (input [0:0] cclk_i   ,input [0:0] creset_i   ,input [width_p-1:0] cdata_i   ,input [0:0] cvalid_i   ,output [0:0] cready_o     ,input [0:0] pclk_i   ,input [0:0] preset_i   ,output [0:0] pvalid_o    ,output [width_p-1:0] pdata_o    ,input [0:0] pready_i   );      wire [0:0] full;     wire [0:0] empty;         wire [0:0] en_w;     wire [0:0] en_r;     wire [width_p-1:0] ram_o;      logic [depth_log2_p:0] wr_add, wr_add_delay,      wr_add_bin2gray, wr_add_sync1, wr_add_sync2,      crossed_wr_add, rd_add, rd_add_delay,      rd_add_bin2gray, rd_add_sync1, rd_add_sync2,      crossed_rd_add, rd_add_next;      assign en_w = cvalid_i &amp;&amp; cready_o;     assign en_r = pready_i &amp;&amp; pvalid_o;      assign full =(wr_add[depth_log2_p-1:0] ===          crossed_rd_add[depth_log2_p-1:0]) &amp;&amp;          (wr_add[depth_log2_p] !==          crossed_rd_add[depth_log2_p]);     assign empty = (crossed_wr_add === rd_add);     assign cready_o = ~full;     assign pvalid_o = ~empty;    // cross for wr_add from consumer to producer side   // convert the write address to gray encoding   bin2gray   #(.width_p(depth_log2_p+1))   bin2gray_inst_wr_add   (.bin_i(wr_add)   ,.gray_o(wr_add_bin2gray));    //delay the grey encoded write address for 1 cc   always_ff @(posedge cclk_i) begin      if (creset_i) begin       wr_add_delay &lt;= &#39;0;     end     else begin       wr_add_delay &lt;= wr_add_bin2gray;     end   end    // two stages of synchronizers   always_ff @(posedge pclk_i) begin     if(preset_i) begin        wr_add_sync1 &lt;= &#39;0;        wr_add_sync2 &lt;= &#39;0;     end     else begin        wr_add_sync1 &lt;= wr_add_delay;       wr_add_sync2 &lt;= wr_add_sync1;     end   end    // convert write address to bin encoding   gray2bin   #(.width_p(depth_log2_p+1))     gray2bin_inst_wr_add    (.gray_i(wr_add_sync2)     ,.bin_o(crossed_wr_add));      // cross for rd_add from producer to consumer side   // convert to gray encoding   bin_to_gray   #(.width_p(depth_log2_p+1))   bin2gray_inst_rd_add   (.bin_i(rd_add)   ,.gray_o(rd_add_bin2gray));    // two stages of synchronizers   always_ff @(posedge cclk_i) begin     if(creset_i) begin        rd_add_sync1 &lt;= &#39;0;        rd_add_sync2 &lt;= &#39;0;     end     else begin        rd_add_sync1 &lt;= rd_add_bin2gray;       rd_add_sync2 &lt;= rd_add_sync1;     end   end    // convert back to bin encoding   gray_to_bin   #(.width_p(depth_log2_p+1))     gray2bin_inst_rd_add    (.gray_i(rd_add_sync2)     ,.bin_o(crossed_rd_add));      always_ff @(posedge cclk_i) begin     if(creset_i) begin        wr_add &lt;= &#39;0;     end     else if (en_w) begin       wr_add &lt;= wr_add + 1;     end   end    always_ff @(posedge pclk_i) begin     if (preset_i) begin       rd_add &lt;= &#39;0;     end      else if (en_r) begin       rd_add &lt;= rd_add + 1;     end   end    always_comb begin      rd_add_next = rd_add;     if(en_r) begin       rd_add_next = rd_add + 1;     end   end    ram_1r1w_sync   #(.width_p(width_p),      .depth_p(1&lt;&lt;depth_log2_p),      .filename_p())      ram_1r1w_sync_inst    (.pclk_i(pclk_i),     .cclk_i(cclk_i),      .preset_i(preset_i),     .creset_i(creset_i),     .wr_valid_i(en_w),     .wr_data_i(cdata_i),     .wr_addr_i(wr_add[depth_log2_p-1:0]),     .rd_valid_i(1&#39;b1),     .rd_addr_i(rd_add_next[depth_log2_p-1:0]),      .rd_data_o(pdata_o));  endmodule">


  <meta name="author" content="Annabella">
  
  <meta property="article:author" content="Annabella">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Slug Silicon">
<meta property="og:title" content="Clock Domain Crossing">
<meta property="og:url" content="http://localhost:4000/concepts/2025/03/15/my-first-post.html">


  <meta property="og:description" content="What is Clock Domain Crossing?  Solutions    Flip-Flop Synchronizers   Binary and Gray Encoding   FIFO Example  What is Clock Domain Crossing?  Clock Domain Crossing (CDC) occurs when data transfers between different clock domains that may differ in frequency or phase. In a multi-clock system, data is first updated synchronously with the edge of the source clock, then it must be safely captured and updated synchronously in the destination clock domain. While simple in theory, there are challenging aspects to consider when attempting to maintain the reliability of data transfer. Signals that originate from one clock domain may not meet the setup and hold time required by the destination clock. Incorrect handling of CDC will lead to timing violations, metastability, data corruption, and other unpredictable behaviors in digital systems.  Though timing issues are a concern when implementing CDC, there are many performance benefits to using multiple clock domains in a digital design.    Decrease the clock rate for some parts of the design while using a higher clock rate when necessary in order to improve power efficiency.   Data throughput can be improved for a high-speed communication protocol while internal interactions operate at a lower clock rate.   There is more design flexibility when utilizing multiple clocks in a single design.   Improves clock tree synthesis results for skew and jitter when there are multiple localized clocks rather than one global clock.   Clock Domain Crossing Solutions  To achieve reliable data transfer, various CDC techniques are used. Some strategies include flip-flop synchronizers, handshake protocols, and FIFO-based solutions. FIFO buffers are particularly useful when handling bulk data transfers across clock domains, which we will explore in detail.  Flip-Flop Synchronizers  Among the most simple ways to solve CDC timing issues is through a flip-flop synchronizer. This uses (usually) two sequential flip-flops triggered by the destination clock. The flip-flop synchronizer solution will allow enough time for a signal to settle and avoid metastability.  module ff_synchronizer (     input  [0:0] clk_dest_i,      // destination clock      input  [0:0] rst_dest_i,      // destination reset     input  [0:0] async_signal_i,  // async input signal     output [0:0] sync_signal_o    // sync output signal );     logic [0:0] stage1_l;  // first stage      logic [0:0] stage2_l;  // second stage       // two sequential flip-flops     always_ff @(posedge clk_dest) begin         if (rst_dest_i) begin             stage1_l &lt;= 1&#39;b0;             stage2_l &lt;= 1&#39;b0;                    end         else begin             stage1_l &lt;= async_signal_i;             stage2_l &lt;= stage1_l;         end     end      assign sync_signal_o = stage2_l;  endmodule   Binary and Gray Encoding  Transferring a data bus is more challenging as binary encoding is unsafe due to the possibility of multiple bits changing in one increment or decrement. This may cause data corruption from some bits updating on the first destination clock synchronizer while other bits remain in their previous state. This is a massive problem for digital design, for example, think about a state machine encoding. If state changes and is passed to the destination clock, corrupted bits may cause the state encoding to point to a nonexistent state.  Instead, Gray code is used because only one bit changes per increment or decrement, making it safer for synchronization as it will either stay in the form of the previous data or update to the correct current data.  module bin_to_gray   #(parameter width_p = 5)   (input [width_p - 1 : 0] bin_i   ,output [width_p - 1 : 0] gray_o);     genvar i;     generate       for(i = width_p -1; i &gt; 0; i = i - 1) begin         assign gray_o[i - 1] = bin_i[i] ^ bin_i[i - 1];       end     endgenerate      assign gray_o[width_p-1] = bin_i[width_p-1];  endmodule   module gray_to_bin   #(parameter width_p = 5)    (input [width_p - 1 : 0] gray_i     ,output [width_p - 1 : 0] bin_o);    genvar i;   generate     for(i = 0; i &lt; width_p; i++) begin       assign bin_o[i] = ^(gray_i &gt;&gt; i);     end   endgenerate  endmodule   FIFO Example  With the previous tools, we can implement a CDC fifo that is capable of transfering bulk data without the threat of data corruption issues. In order to create the CDC FIFO, we must initialize a RAM interface that will read data synchronized to the producer clock and write data synchronized to the consumer clock.  module ram_1r1w_sync   #(parameter [31:0] width_p = 8   ,parameter [31:0] depth_p = 512   ,parameter string filename_p = &quot;memory_init_file.bin&quot;)   (input [0:0] pclk_i   ,input [0:0] cclk_i   ,input [0:0] preset_i   ,input [0:0] creset_i    ,input [0:0] wr_valid_i   ,input [width_p-1:0] wr_data_i   ,input [$clog2(depth_p) - 1 : 0] wr_addr_i    ,input [0:0] rd_valid_i   ,input [$clog2(depth_p) - 1 : 0] rd_addr_i   ,output [width_p-1:0] rd_data_o);    logic [width_p-1:0] ram [depth_p-1:0];     initial begin       for (int i = 0; i &lt; depth_p; i++) begin         ram[i] = &#39;0;       end    end     logic [width_p-1:0] rd_data_l;     always @(posedge pclk_i) begin       if(preset_i) begin          rd_data_l &lt;= &#39;0;       end        else if(rd_valid_i) begin           rd_data_l &lt;= ram[rd_addr_i];       end    end     always @(posedge cclk_i) begin       if(creset_i) begin          ram[wr_addr_i] &lt;= ram[wr_addr_i];       end        else if(wr_valid_i) begin           ram[wr_addr_i] &lt;= wr_data_i;       end    end     assign rd_data_o = rd_data_l;  endmodule   Now we implement the CDC FIFO by connecting the synchronizers, gray encoding, and the two clock port RAM module. We use the RAM module to transfer data between the two clock domains safely. Within the FIFO implementation, the read and write addresses must be transferred between clock domains in order to facilitate the logic for the ready valid handshakes between interfaces.  module fifo_1r1w_cdc  #(parameter [31:0] width_p = 32   ,parameter [31:0] depth_log2_p = 8   )    // the &quot;c&quot; for consumer, and &quot;p&quot; for producer interfaces.    (input [0:0] cclk_i   ,input [0:0] creset_i   ,input [width_p-1:0] cdata_i   ,input [0:0] cvalid_i   ,output [0:0] cready_o     ,input [0:0] pclk_i   ,input [0:0] preset_i   ,output [0:0] pvalid_o    ,output [width_p-1:0] pdata_o    ,input [0:0] pready_i   );      wire [0:0] full;     wire [0:0] empty;         wire [0:0] en_w;     wire [0:0] en_r;     wire [width_p-1:0] ram_o;      logic [depth_log2_p:0] wr_add, wr_add_delay,      wr_add_bin2gray, wr_add_sync1, wr_add_sync2,      crossed_wr_add, rd_add, rd_add_delay,      rd_add_bin2gray, rd_add_sync1, rd_add_sync2,      crossed_rd_add, rd_add_next;      assign en_w = cvalid_i &amp;&amp; cready_o;     assign en_r = pready_i &amp;&amp; pvalid_o;      assign full =(wr_add[depth_log2_p-1:0] ===          crossed_rd_add[depth_log2_p-1:0]) &amp;&amp;          (wr_add[depth_log2_p] !==          crossed_rd_add[depth_log2_p]);     assign empty = (crossed_wr_add === rd_add);     assign cready_o = ~full;     assign pvalid_o = ~empty;    // cross for wr_add from consumer to producer side   // convert the write address to gray encoding   bin2gray   #(.width_p(depth_log2_p+1))   bin2gray_inst_wr_add   (.bin_i(wr_add)   ,.gray_o(wr_add_bin2gray));    //delay the grey encoded write address for 1 cc   always_ff @(posedge cclk_i) begin      if (creset_i) begin       wr_add_delay &lt;= &#39;0;     end     else begin       wr_add_delay &lt;= wr_add_bin2gray;     end   end    // two stages of synchronizers   always_ff @(posedge pclk_i) begin     if(preset_i) begin        wr_add_sync1 &lt;= &#39;0;        wr_add_sync2 &lt;= &#39;0;     end     else begin        wr_add_sync1 &lt;= wr_add_delay;       wr_add_sync2 &lt;= wr_add_sync1;     end   end    // convert write address to bin encoding   gray2bin   #(.width_p(depth_log2_p+1))     gray2bin_inst_wr_add    (.gray_i(wr_add_sync2)     ,.bin_o(crossed_wr_add));      // cross for rd_add from producer to consumer side   // convert to gray encoding   bin_to_gray   #(.width_p(depth_log2_p+1))   bin2gray_inst_rd_add   (.bin_i(rd_add)   ,.gray_o(rd_add_bin2gray));    // two stages of synchronizers   always_ff @(posedge cclk_i) begin     if(creset_i) begin        rd_add_sync1 &lt;= &#39;0;        rd_add_sync2 &lt;= &#39;0;     end     else begin        rd_add_sync1 &lt;= rd_add_bin2gray;       rd_add_sync2 &lt;= rd_add_sync1;     end   end    // convert back to bin encoding   gray_to_bin   #(.width_p(depth_log2_p+1))     gray2bin_inst_rd_add    (.gray_i(rd_add_sync2)     ,.bin_o(crossed_rd_add));      always_ff @(posedge cclk_i) begin     if(creset_i) begin        wr_add &lt;= &#39;0;     end     else if (en_w) begin       wr_add &lt;= wr_add + 1;     end   end    always_ff @(posedge pclk_i) begin     if (preset_i) begin       rd_add &lt;= &#39;0;     end      else if (en_r) begin       rd_add &lt;= rd_add + 1;     end   end    always_comb begin      rd_add_next = rd_add;     if(en_r) begin       rd_add_next = rd_add + 1;     end   end    ram_1r1w_sync   #(.width_p(width_p),      .depth_p(1&lt;&lt;depth_log2_p),      .filename_p())      ram_1r1w_sync_inst    (.pclk_i(pclk_i),     .cclk_i(cclk_i),      .preset_i(preset_i),     .creset_i(creset_i),     .wr_valid_i(en_w),     .wr_data_i(cdata_i),     .wr_addr_i(wr_add[depth_log2_p-1:0]),     .rd_valid_i(1&#39;b1),     .rd_addr_i(rd_add_next[depth_log2_p-1:0]),      .rd_data_o(pdata_o));  endmodule">







  <meta property="article:published_time" content="2025-03-15T00:00:00-07:00">






<link rel="canonical" href="http://localhost:4000/concepts/2025/03/15/my-first-post.html">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Slug Silicon Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script type="text/javascript">
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Slug Silicon
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/"
                
                
              >Home</a>
            </li><li class="masthead__menu-item">
              <a
                href="/concepts/"
                
                
              >Concepts & Tutorials </a>
            </li><li class="masthead__menu-item">
              <a
                href="/projects/"
                
                
              >Projects</a>
            </li><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person" class="h-card">

  
    <div class="author__avatar">
      <a href="http://localhost:4000/">
        <img src="/assets/images/avatar.png" alt="Annabella" itemprop="image" class="u-photo">
      </a>
    </div>
  

  <div class="author__content">
    <h3 class="author__name p-name" itemprop="name">
      <a class="u-url" rel="me" href="http://localhost:4000/" itemprop="url">Annabella</a>
    </h3>
    
      <div class="author__bio p-note" itemprop="description">
        <p>Computer Engineering @ UCSC</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      

      
        
          
            <li><a href="https://github.com/anbellumToo" rel="nofollow noopener noreferrer me" itemprop="sameAs"><i class="fab fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer me">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Clock Domain Crossing">
    <meta itemprop="description" content="What is Clock Domain Crossing?Solutions  Flip-Flop Synchronizers  Binary and Gray EncodingFIFO ExampleWhat is Clock Domain Crossing?Clock Domain Crossing (CDC) occurs when data transfers between different clock domains that may differ in frequency or phase. In a multi-clock system, data is first updated synchronously with the edge of the source clock, then it must be safely captured and updated synchronously in the destination clock domain. While simple in theory, there are challenging aspects to consider when attempting to maintain the reliability of data transfer. Signals that originate from one clock domain may not meet the setup and hold time required by the destination clock. Incorrect handling of CDC will lead to timing violations, metastability, data corruption, and other unpredictable behaviors in digital systems.Though timing issues are a concern when implementing CDC, there are many performance benefits to using multiple clock domains in a digital design.  Decrease the clock rate for some parts of the design while using a higher clock rate when necessary in order to improve power efficiency.  Data throughput can be improved for a high-speed communication protocol while internal interactions operate at a lower clock rate.  There is more design flexibility when utilizing multiple clocks in a single design.  Improves clock tree synthesis results for skew and jitter when there are multiple localized clocks rather than one global clock.Clock Domain Crossing SolutionsTo achieve reliable data transfer, various CDC techniques are used. Some strategies include flip-flop synchronizers, handshake protocols, and FIFO-based solutions. FIFO buffers are particularly useful when handling bulk data transfers across clock domains, which we will explore in detail.Flip-Flop SynchronizersAmong the most simple ways to solve CDC timing issues is through a flip-flop synchronizer. This uses (usually) two sequential flip-flops triggered by the destination clock. The flip-flop synchronizer solution will allow enough time for a signal to settle and avoid metastability.module ff_synchronizer (    input  [0:0] clk_dest_i,      // destination clock     input  [0:0] rst_dest_i,      // destination reset    input  [0:0] async_signal_i,  // async input signal    output [0:0] sync_signal_o    // sync output signal);    logic [0:0] stage1_l;  // first stage     logic [0:0] stage2_l;  // second stage     // two sequential flip-flops    always_ff @(posedge clk_dest) begin        if (rst_dest_i) begin            stage1_l &lt;= 1&#39;b0;            stage2_l &lt;= 1&#39;b0;                   end        else begin            stage1_l &lt;= async_signal_i;            stage2_l &lt;= stage1_l;        end    end    assign sync_signal_o = stage2_l;endmoduleBinary and Gray EncodingTransferring a data bus is more challenging as binary encoding is unsafe due to the possibility of multiple bits changing in one increment or decrement. This may cause data corruption from some bits updating on the first destination clock synchronizer while other bits remain in their previous state. This is a massive problem for digital design, for example, think about a state machine encoding. If state changes and is passed to the destination clock, corrupted bits may cause the state encoding to point to a nonexistent state.Instead, Gray code is used because only one bit changes per increment or decrement, making it safer for synchronization as it will either stay in the form of the previous data or update to the correct current data.module bin_to_gray  #(parameter width_p = 5)  (input [width_p - 1 : 0] bin_i  ,output [width_p - 1 : 0] gray_o);   genvar i;    generate      for(i = width_p -1; i &gt; 0; i = i - 1) begin        assign gray_o[i - 1] = bin_i[i] ^ bin_i[i - 1];      end    endgenerate    assign gray_o[width_p-1] = bin_i[width_p-1];endmodulemodule gray_to_bin  #(parameter width_p = 5)   (input [width_p - 1 : 0] gray_i    ,output [width_p - 1 : 0] bin_o);  genvar i;  generate    for(i = 0; i &lt; width_p; i++) begin      assign bin_o[i] = ^(gray_i &gt;&gt; i);    end  endgenerateendmoduleFIFO ExampleWith the previous tools, we can implement a CDC fifo that is capable of transfering bulk data without the threat of data corruption issues. In order to create the CDC FIFO, we must initialize a RAM interface that will read data synchronized to the producer clock and write data synchronized to the consumer clock.module ram_1r1w_sync  #(parameter [31:0] width_p = 8  ,parameter [31:0] depth_p = 512  ,parameter string filename_p = &quot;memory_init_file.bin&quot;)  (input [0:0] pclk_i  ,input [0:0] cclk_i  ,input [0:0] preset_i  ,input [0:0] creset_i  ,input [0:0] wr_valid_i  ,input [width_p-1:0] wr_data_i  ,input [$clog2(depth_p) - 1 : 0] wr_addr_i  ,input [0:0] rd_valid_i  ,input [$clog2(depth_p) - 1 : 0] rd_addr_i  ,output [width_p-1:0] rd_data_o);   logic [width_p-1:0] ram [depth_p-1:0];   initial begin      for (int i = 0; i &lt; depth_p; i++) begin        ram[i] = &#39;0;      end   end   logic [width_p-1:0] rd_data_l;   always @(posedge pclk_i) begin      if(preset_i) begin         rd_data_l &lt;= &#39;0;      end       else if(rd_valid_i) begin          rd_data_l &lt;= ram[rd_addr_i];      end   end   always @(posedge cclk_i) begin      if(creset_i) begin         ram[wr_addr_i] &lt;= ram[wr_addr_i];      end       else if(wr_valid_i) begin          ram[wr_addr_i] &lt;= wr_data_i;      end   end   assign rd_data_o = rd_data_l;endmoduleNow we implement the CDC FIFO by connecting the synchronizers, gray encoding, and the two clock port RAM module. We use the RAM module to transfer data between the two clock domains safely. Within the FIFO implementation, the read and write addresses must be transferred between clock domains in order to facilitate the logic for the ready valid handshakes between interfaces.module fifo_1r1w_cdc #(parameter [31:0] width_p = 32  ,parameter [31:0] depth_log2_p = 8  )   // the &quot;c&quot; for consumer, and &quot;p&quot; for producer interfaces.   (input [0:0] cclk_i  ,input [0:0] creset_i  ,input [width_p-1:0] cdata_i  ,input [0:0] cvalid_i  ,output [0:0] cready_o   ,input [0:0] pclk_i  ,input [0:0] preset_i  ,output [0:0] pvalid_o   ,output [width_p-1:0] pdata_o   ,input [0:0] pready_i  );    wire [0:0] full;    wire [0:0] empty;       wire [0:0] en_w;    wire [0:0] en_r;    wire [width_p-1:0] ram_o;    logic [depth_log2_p:0] wr_add, wr_add_delay,     wr_add_bin2gray, wr_add_sync1, wr_add_sync2,     crossed_wr_add, rd_add, rd_add_delay,     rd_add_bin2gray, rd_add_sync1, rd_add_sync2,     crossed_rd_add, rd_add_next;    assign en_w = cvalid_i &amp;&amp; cready_o;    assign en_r = pready_i &amp;&amp; pvalid_o;    assign full =(wr_add[depth_log2_p-1:0] ===         crossed_rd_add[depth_log2_p-1:0]) &amp;&amp;         (wr_add[depth_log2_p] !==         crossed_rd_add[depth_log2_p]);    assign empty = (crossed_wr_add === rd_add);    assign cready_o = ~full;    assign pvalid_o = ~empty;  // cross for wr_add from consumer to producer side  // convert the write address to gray encoding  bin2gray  #(.width_p(depth_log2_p+1))  bin2gray_inst_wr_add  (.bin_i(wr_add)  ,.gray_o(wr_add_bin2gray));  //delay the grey encoded write address for 1 cc  always_ff @(posedge cclk_i) begin     if (creset_i) begin      wr_add_delay &lt;= &#39;0;    end    else begin      wr_add_delay &lt;= wr_add_bin2gray;    end  end  // two stages of synchronizers  always_ff @(posedge pclk_i) begin    if(preset_i) begin       wr_add_sync1 &lt;= &#39;0;       wr_add_sync2 &lt;= &#39;0;    end    else begin       wr_add_sync1 &lt;= wr_add_delay;      wr_add_sync2 &lt;= wr_add_sync1;    end  end  // convert write address to bin encoding  gray2bin  #(.width_p(depth_log2_p+1))    gray2bin_inst_wr_add   (.gray_i(wr_add_sync2)    ,.bin_o(crossed_wr_add));    // cross for rd_add from producer to consumer side  // convert to gray encoding  bin_to_gray  #(.width_p(depth_log2_p+1))  bin2gray_inst_rd_add  (.bin_i(rd_add)  ,.gray_o(rd_add_bin2gray));  // two stages of synchronizers  always_ff @(posedge cclk_i) begin    if(creset_i) begin       rd_add_sync1 &lt;= &#39;0;       rd_add_sync2 &lt;= &#39;0;    end    else begin       rd_add_sync1 &lt;= rd_add_bin2gray;      rd_add_sync2 &lt;= rd_add_sync1;    end  end  // convert back to bin encoding  gray_to_bin  #(.width_p(depth_log2_p+1))    gray2bin_inst_rd_add   (.gray_i(rd_add_sync2)    ,.bin_o(crossed_rd_add));    always_ff @(posedge cclk_i) begin    if(creset_i) begin       wr_add &lt;= &#39;0;    end    else if (en_w) begin      wr_add &lt;= wr_add + 1;    end  end  always_ff @(posedge pclk_i) begin    if (preset_i) begin      rd_add &lt;= &#39;0;    end     else if (en_r) begin      rd_add &lt;= rd_add + 1;    end  end  always_comb begin     rd_add_next = rd_add;    if(en_r) begin      rd_add_next = rd_add + 1;    end  end  ram_1r1w_sync  #(.width_p(width_p),     .depth_p(1&lt;&lt;depth_log2_p),     .filename_p())     ram_1r1w_sync_inst   (.pclk_i(pclk_i),    .cclk_i(cclk_i),     .preset_i(preset_i),    .creset_i(creset_i),    .wr_valid_i(en_w),    .wr_data_i(cdata_i),    .wr_addr_i(wr_add[depth_log2_p-1:0]),    .rd_valid_i(1&#39;b1),    .rd_addr_i(rd_add_next[depth_log2_p-1:0]),     .rd_data_o(pdata_o));endmodule">
    <meta itemprop="datePublished" content="2025-03-15T00:00:00-07:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="http://localhost:4000/concepts/2025/03/15/my-first-post.html" itemprop="url">Clock Domain Crossing
</a>
          </h1>
          


        </header>
      

      <section class="page__content" itemprop="text">
        
        <p><a href="#what-is-clock-domain-crossing">What is Clock Domain Crossing?</a></p>

<p><a href="#clock-domain-crossing-solutions">Solutions</a></p>
<ul>
  <li><a href="#flip-flop-synchronizers">Flip-Flop Synchronizers</a></li>
  <li><a href="#binary-and-gray-encoding">Binary and Gray Encoding</a></li>
</ul>

<p><a href="#fifo-example">FIFO Example</a></p>

<h2 id="what-is-clock-domain-crossing">What is Clock Domain Crossing?</h2>

<p>Clock Domain Crossing (CDC) occurs when data transfers between different clock domains that may differ in frequency or phase. In a multi-clock system, data is first updated synchronously with the edge of the source clock, then it must be safely captured and updated synchronously in the destination clock domain. While simple in theory, there are challenging aspects to consider when attempting to maintain the reliability of data transfer. Signals that originate from one clock domain may not meet the setup and hold time required by the destination clock. Incorrect handling of CDC will lead to timing violations, metastability, data corruption, and other unpredictable behaviors in digital systems.</p>

<p>Though timing issues are a concern when implementing CDC, there are many performance benefits to using multiple clock domains in a digital design.</p>
<ul>
  <li>Decrease the clock rate for some parts of the design while using a higher clock rate when necessary in order to improve power efficiency.</li>
  <li>Data throughput can be improved for a high-speed communication protocol while internal interactions operate at a lower clock rate.</li>
  <li>There is more design flexibility when utilizing multiple clocks in a single design.</li>
  <li>Improves clock tree synthesis results for skew and jitter when there are multiple localized clocks rather than one global clock.</li>
</ul>

<h2 id="clock-domain-crossing-solutions">Clock Domain Crossing Solutions</h2>

<p>To achieve reliable data transfer, various CDC techniques are used. Some strategies include flip-flop synchronizers, handshake protocols, and FIFO-based solutions. FIFO buffers are particularly useful when handling bulk data transfers across clock domains, which we will explore in detail.</p>

<h4 id="flip-flop-synchronizers">Flip-Flop Synchronizers</h4>

<p>Among the most simple ways to solve CDC timing issues is through a flip-flop synchronizer. This uses (usually) two sequential flip-flops triggered by the destination clock. The flip-flop synchronizer solution will allow enough time for a signal to settle and avoid metastability.</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="n">ff_synchronizer</span> <span class="p">(</span>
    <span class="kt">input</span>  <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">clk_dest_i</span><span class="p">,</span>      <span class="c1">// destination clock </span>
    <span class="kt">input</span>  <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">rst_dest_i</span><span class="p">,</span>      <span class="c1">// destination reset</span>
    <span class="kt">input</span>  <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">async_signal_i</span><span class="p">,</span>  <span class="c1">// async input signal</span>
    <span class="kt">output</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">sync_signal_o</span>    <span class="c1">// sync output signal</span>
<span class="p">);</span>
    <span class="kt">logic</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">stage1_l</span><span class="p">;</span>  <span class="c1">// first stage </span>
    <span class="kt">logic</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">stage2_l</span><span class="p">;</span>  <span class="c1">// second stage </span>

    <span class="c1">// two sequential flip-flops</span>
    <span class="k">always_ff</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clk_dest</span><span class="p">)</span> <span class="k">begin</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rst_dest_i</span><span class="p">)</span> <span class="k">begin</span>
            <span class="n">stage1_l</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
            <span class="n">stage2_l</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>           
        <span class="k">end</span>
        <span class="k">else</span> <span class="k">begin</span>
            <span class="n">stage1_l</span> <span class="o">&lt;=</span> <span class="n">async_signal_i</span><span class="p">;</span>
            <span class="n">stage2_l</span> <span class="o">&lt;=</span> <span class="n">stage1_l</span><span class="p">;</span>
        <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">assign</span> <span class="n">sync_signal_o</span> <span class="o">=</span> <span class="n">stage2_l</span><span class="p">;</span>

<span class="k">endmodule</span>
</code></pre></div></div>

<h4 id="binary-and-gray-encoding">Binary and Gray Encoding</h4>

<p>Transferring a data bus is more challenging as binary encoding is unsafe due to the possibility of multiple bits changing in one increment or decrement. This may cause data corruption from some bits updating on the first destination clock synchronizer while other bits remain in their previous state. This is a massive problem for digital design, for example, think about a state machine encoding. If state changes and is passed to the destination clock, corrupted bits may cause the state encoding to point to a nonexistent state.</p>

<p>Instead, Gray code is used because only one bit changes per increment or decrement, making it safer for synchronization as it will either stay in the form of the previous data or update to the correct current data.</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="n">bin_to_gray</span>
  <span class="p">#(</span><span class="k">parameter</span> <span class="n">width_p</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
  <span class="p">(</span><span class="kt">input</span> <span class="p">[</span><span class="n">width_p</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">bin_i</span>
  <span class="p">,</span><span class="kt">output</span> <span class="p">[</span><span class="n">width_p</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">gray_o</span><span class="p">);</span>

   <span class="k">genvar</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">generate</span>
      <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">width_p</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">begin</span>
        <span class="k">assign</span> <span class="n">gray_o</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">bin_i</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
      <span class="k">end</span>
    <span class="k">endgenerate</span>

    <span class="k">assign</span> <span class="n">gray_o</span><span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_i</span><span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>

<span class="k">endmodule</span>
</code></pre></div></div>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="n">gray_to_bin</span>
  <span class="p">#(</span><span class="k">parameter</span> <span class="n">width_p</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
   <span class="p">(</span><span class="kt">input</span> <span class="p">[</span><span class="n">width_p</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">gray_i</span>
    <span class="p">,</span><span class="kt">output</span> <span class="p">[</span><span class="n">width_p</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">bin_o</span><span class="p">);</span>

  <span class="k">genvar</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">generate</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">width_p</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
      <span class="k">assign</span> <span class="n">bin_o</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">gray_i</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">);</span>
    <span class="k">end</span>
  <span class="k">endgenerate</span>

<span class="k">endmodule</span>
</code></pre></div></div>

<h2 id="fifo-example">FIFO Example</h2>

<p>With the previous tools, we can implement a CDC fifo that is capable of transfering bulk data without the threat of data corruption issues. In order to create the CDC FIFO, we must initialize a RAM interface that will read data synchronized to the producer clock and write data synchronized to the consumer clock.</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="n">ram_1r1w_sync</span>
  <span class="p">#(</span><span class="k">parameter</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">width_p</span> <span class="o">=</span> <span class="mi">8</span>
  <span class="p">,</span><span class="k">parameter</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">depth_p</span> <span class="o">=</span> <span class="mi">512</span>
  <span class="p">,</span><span class="k">parameter</span> <span class="kt">string</span> <span class="n">filename_p</span> <span class="o">=</span> <span class="s">"memory_init_file.bin"</span><span class="p">)</span>
  <span class="p">(</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">pclk_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">cclk_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">preset_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">creset_i</span>

  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">wr_valid_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">wr_data_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">depth_p</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">wr_addr_i</span>

  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">rd_valid_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">depth_p</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">rd_addr_i</span>
  <span class="p">,</span><span class="kt">output</span> <span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">rd_data_o</span><span class="p">);</span>
   <span class="kt">logic</span> <span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">ram</span> <span class="p">[</span><span class="n">depth_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>

   <span class="k">initial</span> <span class="k">begin</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">depth_p</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
        <span class="n">ram</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mb">'0</span><span class="p">;</span>
      <span class="k">end</span>
   <span class="k">end</span>

   <span class="kt">logic</span> <span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">rd_data_l</span><span class="p">;</span>

   <span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">pclk_i</span><span class="p">)</span> <span class="k">begin</span>
      <span class="k">if</span><span class="p">(</span><span class="n">preset_i</span><span class="p">)</span> <span class="k">begin</span>
         <span class="n">rd_data_l</span> <span class="o">&lt;=</span> <span class="mb">'0</span><span class="p">;</span>
      <span class="k">end</span> 
      <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rd_valid_i</span><span class="p">)</span> <span class="k">begin</span>
          <span class="n">rd_data_l</span> <span class="o">&lt;=</span> <span class="n">ram</span><span class="p">[</span><span class="n">rd_addr_i</span><span class="p">];</span>
      <span class="k">end</span>
   <span class="k">end</span>

   <span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">cclk_i</span><span class="p">)</span> <span class="k">begin</span>
      <span class="k">if</span><span class="p">(</span><span class="n">creset_i</span><span class="p">)</span> <span class="k">begin</span>
         <span class="n">ram</span><span class="p">[</span><span class="n">wr_addr_i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ram</span><span class="p">[</span><span class="n">wr_addr_i</span><span class="p">];</span>
      <span class="k">end</span> 
      <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">wr_valid_i</span><span class="p">)</span> <span class="k">begin</span>
          <span class="n">ram</span><span class="p">[</span><span class="n">wr_addr_i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">wr_data_i</span><span class="p">;</span>
      <span class="k">end</span>
   <span class="k">end</span>

   <span class="k">assign</span> <span class="n">rd_data_o</span> <span class="o">=</span> <span class="n">rd_data_l</span><span class="p">;</span>

<span class="k">endmodule</span>
</code></pre></div></div>

<p>Now we implement the CDC FIFO by connecting the synchronizers, gray encoding, and the two clock port RAM module. We use the RAM module to transfer data between the two clock domains safely. Within the FIFO implementation, the read and write addresses must be transferred between clock domains in order to facilitate the logic for the ready valid handshakes between interfaces.</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="n">fifo_1r1w_cdc</span>
 <span class="p">#(</span><span class="k">parameter</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">width_p</span> <span class="o">=</span> <span class="mi">32</span>
  <span class="p">,</span><span class="k">parameter</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">depth_log2_p</span> <span class="o">=</span> <span class="mi">8</span>
  <span class="p">)</span>
   <span class="c1">// the "c" for consumer, and "p" for producer interfaces. </span>
  <span class="p">(</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">cclk_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">creset_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">cdata_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">cvalid_i</span>
  <span class="p">,</span><span class="kt">output</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">cready_o</span> 

  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">pclk_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">preset_i</span>
  <span class="p">,</span><span class="kt">output</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">pvalid_o</span> 
  <span class="p">,</span><span class="kt">output</span> <span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">pdata_o</span> 
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">pready_i</span>
  <span class="p">);</span>

    <span class="kt">wire</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">full</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">empty</span><span class="p">;</span>
   
    <span class="kt">wire</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">en_w</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">en_r</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">ram_o</span><span class="p">;</span>

    <span class="kt">logic</span> <span class="p">[</span><span class="n">depth_log2_p</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">wr_add</span><span class="p">,</span> <span class="n">wr_add_delay</span><span class="p">,</span> 
    <span class="n">wr_add_bin2gray</span><span class="p">,</span> <span class="n">wr_add_sync1</span><span class="p">,</span> <span class="n">wr_add_sync2</span><span class="p">,</span> 
    <span class="n">crossed_wr_add</span><span class="p">,</span> <span class="n">rd_add</span><span class="p">,</span> <span class="n">rd_add_delay</span><span class="p">,</span> 
    <span class="n">rd_add_bin2gray</span><span class="p">,</span> <span class="n">rd_add_sync1</span><span class="p">,</span> <span class="n">rd_add_sync2</span><span class="p">,</span> 
    <span class="n">crossed_rd_add</span><span class="p">,</span> <span class="n">rd_add_next</span><span class="p">;</span>

    <span class="k">assign</span> <span class="n">en_w</span> <span class="o">=</span> <span class="n">cvalid_i</span> <span class="o">&amp;&amp;</span> <span class="n">cready_o</span><span class="p">;</span>
    <span class="k">assign</span> <span class="n">en_r</span> <span class="o">=</span> <span class="n">pready_i</span> <span class="o">&amp;&amp;</span> <span class="n">pvalid_o</span><span class="p">;</span>

    <span class="k">assign</span> <span class="n">full</span> <span class="o">=</span><span class="p">(</span><span class="n">wr_add</span><span class="p">[</span><span class="n">depth_log2_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> 
        <span class="n">crossed_rd_add</span><span class="p">[</span><span class="n">depth_log2_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;&amp;</span> 
        <span class="p">(</span><span class="n">wr_add</span><span class="p">[</span><span class="n">depth_log2_p</span><span class="p">]</span> <span class="o">!==</span> 
        <span class="n">crossed_rd_add</span><span class="p">[</span><span class="n">depth_log2_p</span><span class="p">]);</span>
    <span class="k">assign</span> <span class="n">empty</span> <span class="o">=</span> <span class="p">(</span><span class="n">crossed_wr_add</span> <span class="o">===</span> <span class="n">rd_add</span><span class="p">);</span>
    <span class="k">assign</span> <span class="n">cready_o</span> <span class="o">=</span> <span class="o">~</span><span class="n">full</span><span class="p">;</span>
    <span class="k">assign</span> <span class="n">pvalid_o</span> <span class="o">=</span> <span class="o">~</span><span class="n">empty</span><span class="p">;</span>

  <span class="c1">// cross for wr_add from consumer to producer side</span>
  <span class="c1">// convert the write address to gray encoding</span>
  <span class="n">bin2gray</span>
  <span class="p">#(.</span><span class="n">width_p</span><span class="p">(</span><span class="n">depth_log2_p</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
  <span class="n">bin2gray_inst_wr_add</span>
  <span class="p">(.</span><span class="n">bin_i</span><span class="p">(</span><span class="n">wr_add</span><span class="p">)</span>
  <span class="p">,.</span><span class="n">gray_o</span><span class="p">(</span><span class="n">wr_add_bin2gray</span><span class="p">));</span>

  <span class="c1">//delay the grey encoded write address for 1 cc</span>
  <span class="k">always_ff</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">cclk_i</span><span class="p">)</span> <span class="k">begin</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">creset_i</span><span class="p">)</span> <span class="k">begin</span>
      <span class="n">wr_add_delay</span> <span class="o">&lt;=</span> <span class="mb">'0</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="k">else</span> <span class="k">begin</span>
      <span class="n">wr_add_delay</span> <span class="o">&lt;=</span> <span class="n">wr_add_bin2gray</span><span class="p">;</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1">// two stages of synchronizers</span>
  <span class="k">always_ff</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">pclk_i</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="n">preset_i</span><span class="p">)</span> <span class="k">begin</span> 
      <span class="n">wr_add_sync1</span> <span class="o">&lt;=</span> <span class="mb">'0</span><span class="p">;</span> 
      <span class="n">wr_add_sync2</span> <span class="o">&lt;=</span> <span class="mb">'0</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="k">else</span> <span class="k">begin</span> 
      <span class="n">wr_add_sync1</span> <span class="o">&lt;=</span> <span class="n">wr_add_delay</span><span class="p">;</span>
      <span class="n">wr_add_sync2</span> <span class="o">&lt;=</span> <span class="n">wr_add_sync1</span><span class="p">;</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1">// convert write address to bin encoding</span>
  <span class="n">gray2bin</span>
  <span class="p">#(.</span><span class="n">width_p</span><span class="p">(</span><span class="n">depth_log2_p</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">gray2bin_inst_wr_add</span>
   <span class="p">(.</span><span class="n">gray_i</span><span class="p">(</span><span class="n">wr_add_sync2</span><span class="p">)</span>
    <span class="p">,.</span><span class="n">bin_o</span><span class="p">(</span><span class="n">crossed_wr_add</span><span class="p">));</span>  

  <span class="c1">// cross for rd_add from producer to consumer side</span>
  <span class="c1">// convert to gray encoding</span>
  <span class="n">bin_to_gray</span>
  <span class="p">#(.</span><span class="n">width_p</span><span class="p">(</span><span class="n">depth_log2_p</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
  <span class="n">bin2gray_inst_rd_add</span>
  <span class="p">(.</span><span class="n">bin_i</span><span class="p">(</span><span class="n">rd_add</span><span class="p">)</span>
  <span class="p">,.</span><span class="n">gray_o</span><span class="p">(</span><span class="n">rd_add_bin2gray</span><span class="p">));</span>

  <span class="c1">// two stages of synchronizers</span>
  <span class="k">always_ff</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">cclk_i</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="n">creset_i</span><span class="p">)</span> <span class="k">begin</span> 
      <span class="n">rd_add_sync1</span> <span class="o">&lt;=</span> <span class="mb">'0</span><span class="p">;</span> 
      <span class="n">rd_add_sync2</span> <span class="o">&lt;=</span> <span class="mb">'0</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="k">else</span> <span class="k">begin</span> 
      <span class="n">rd_add_sync1</span> <span class="o">&lt;=</span> <span class="n">rd_add_bin2gray</span><span class="p">;</span>
      <span class="n">rd_add_sync2</span> <span class="o">&lt;=</span> <span class="n">rd_add_sync1</span><span class="p">;</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1">// convert back to bin encoding</span>
  <span class="n">gray_to_bin</span>
  <span class="p">#(.</span><span class="n">width_p</span><span class="p">(</span><span class="n">depth_log2_p</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">gray2bin_inst_rd_add</span>
   <span class="p">(.</span><span class="n">gray_i</span><span class="p">(</span><span class="n">rd_add_sync2</span><span class="p">)</span>
    <span class="p">,.</span><span class="n">bin_o</span><span class="p">(</span><span class="n">crossed_rd_add</span><span class="p">));</span>  

  <span class="k">always_ff</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">cclk_i</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="n">creset_i</span><span class="p">)</span> <span class="k">begin</span> 
      <span class="n">wr_add</span> <span class="o">&lt;=</span> <span class="mb">'0</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">en_w</span><span class="p">)</span> <span class="k">begin</span>
      <span class="n">wr_add</span> <span class="o">&lt;=</span> <span class="n">wr_add</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">always_ff</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">pclk_i</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">preset_i</span><span class="p">)</span> <span class="k">begin</span>
      <span class="n">rd_add</span> <span class="o">&lt;=</span> <span class="mb">'0</span><span class="p">;</span>
    <span class="k">end</span> 
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">en_r</span><span class="p">)</span> <span class="k">begin</span>
      <span class="n">rd_add</span> <span class="o">&lt;=</span> <span class="n">rd_add</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">always_comb</span> <span class="k">begin</span> 
    <span class="n">rd_add_next</span> <span class="o">=</span> <span class="n">rd_add</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">en_r</span><span class="p">)</span> <span class="k">begin</span>
      <span class="n">rd_add_next</span> <span class="o">=</span> <span class="n">rd_add</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">ram_1r1w_sync</span>
  <span class="p">#(.</span><span class="n">width_p</span><span class="p">(</span><span class="n">width_p</span><span class="p">),</span> 
    <span class="p">.</span><span class="n">depth_p</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">depth_log2_p</span><span class="p">),</span> 
    <span class="p">.</span><span class="n">filename_p</span><span class="p">())</span> 
    <span class="n">ram_1r1w_sync_inst</span>
   <span class="p">(.</span><span class="n">pclk_i</span><span class="p">(</span><span class="n">pclk_i</span><span class="p">),</span> 
   <span class="p">.</span><span class="n">cclk_i</span><span class="p">(</span><span class="n">cclk_i</span><span class="p">),</span> 
    <span class="p">.</span><span class="n">preset_i</span><span class="p">(</span><span class="n">preset_i</span><span class="p">),</span>
    <span class="p">.</span><span class="n">creset_i</span><span class="p">(</span><span class="n">creset_i</span><span class="p">),</span>
    <span class="p">.</span><span class="n">wr_valid_i</span><span class="p">(</span><span class="n">en_w</span><span class="p">),</span>
    <span class="p">.</span><span class="n">wr_data_i</span><span class="p">(</span><span class="n">cdata_i</span><span class="p">),</span>
    <span class="p">.</span><span class="n">wr_addr_i</span><span class="p">(</span><span class="n">wr_add</span><span class="p">[</span><span class="n">depth_log2_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]),</span>
    <span class="p">.</span><span class="n">rd_valid_i</span><span class="p">(</span><span class="mb">1'b1</span><span class="p">),</span>
    <span class="p">.</span><span class="n">rd_addr_i</span><span class="p">(</span><span class="n">rd_add_next</span><span class="p">[</span><span class="n">depth_log2_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]),</span> 
    <span class="p">.</span><span class="n">rd_data_o</span><span class="p">(</span><span class="n">pdata_o</span><span class="p">));</span>

<span class="k">endmodule</span>
</code></pre></div></div>


        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2025-03-15T00:00:00-07:00">March 15, 2025</time></p>

      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://github.com/anbellumToo" rel="nofollow noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/annabella-newton/" rel="nofollow noopener noreferrer"><i class="fab fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 <a href="http://localhost:4000">Slug Silicon</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>






  </body>
</html>
