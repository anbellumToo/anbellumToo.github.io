<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-03-19T15:48:31-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Slug Silicon</title><subtitle>A Jekyll site using the Minimal Mistakes theme.</subtitle><author><name>Annabella</name></author><entry><title type="html">Clock Domain Crossing</title><link href="http://localhost:4000/concepts/2025/03/15/my-first-post.html" rel="alternate" type="text/html" title="Clock Domain Crossing" /><published>2025-03-15T00:00:00-07:00</published><updated>2025-03-15T00:00:00-07:00</updated><id>http://localhost:4000/concepts/2025/03/15/my-first-post</id><content type="html" xml:base="http://localhost:4000/concepts/2025/03/15/my-first-post.html"><![CDATA[<p><a href="#what-is-clock-domain-crossing">What is Clock Domain Crossing?</a></p>

<p><a href="#clock-domain-crossing-solutions">Solutions</a></p>
<ul>
  <li><a href="#flip-flop-synchronizers">Flip-Flop Synchronizers</a></li>
  <li><a href="#binary-and-gray-encoding">Binary and Gray Encoding</a></li>
  <li><a href="#pulse-stretching">Pulse Stretching</a></li>
  <li><a href="#fifo-example">FIFO Example</a></li>
</ul>

<h2 id="what-is-clock-domain-crossing">What is Clock Domain Crossing?</h2>

<p>Clock Domain Crossing (CDC) occurs when data transfers between different clock domains that may differ in frequency or phase. In a multi-clock system, data is first updated synchronously with the edge of the source clock, then it must be safely captured and updated synchronously in the destination clock domain. While simple in theory, there are challenging aspects to consider when attempting to maintain the reliability of data transfer. Signals that originate from one clock domain may not meet the setup and hold time required by the destination clock. Incorrect handling of CDC will lead to timing violations, metastability, data corruption, and other unpredictable behaviors in digital systems.</p>

<p>Though timing issues are a concern when implementing CDC, there are many performance benefits to using multiple clock domains in a digital design.</p>
<ul>
  <li>Decrease the clock rate for some parts of the design while using a higher clock rate when necessary in order to improve power efficiency.</li>
  <li>Data throughput can be improved for a high-speed communication protocol while internal interactions operate at a lower clock rate.</li>
  <li>There is more design flexibility when utilizing multiple clocks in a single design.</li>
  <li>Improves clock tree synthesis results for skew and jitter when there are multiple localized clocks rather than one global clock.</li>
</ul>

<h2 id="clock-domain-crossing-solutions">Clock Domain Crossing Solutions</h2>

<p>To achieve reliable data transfer, various CDC techniques are used. Some strategies include flip-flop synchronizers, handshake protocols, and FIFO-based solutions. FIFO buffers are particularly useful when handling bulk data transfers across clock domains, which we will explore in detail.</p>

<h4 id="flip-flop-synchronizers">Flip-Flop Synchronizers</h4>

<p>Among the most simple ways to solve CDC timing issues is through a flip-flop synchronizer. This uses (usually) two sequential flip-flops triggered by the destination clock. The flip-flop synchronizer solution will allow enough time for a signal to settle and avoid metastability.</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="n">ff_synchronizer</span> <span class="p">(</span>
    <span class="kt">input</span>  <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">clk_dest_i</span><span class="p">,</span>      <span class="c1">// destination clock </span>
    <span class="kt">input</span>  <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">rst_dest_i</span><span class="p">,</span>      <span class="c1">// destination reset</span>
    <span class="kt">input</span>  <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">async_signal_i</span><span class="p">,</span>  <span class="c1">// async input signal</span>
    <span class="kt">output</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">sync_signal_o</span>    <span class="c1">// sync output signal</span>
<span class="p">);</span>
    <span class="kt">logic</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">stage1_l</span><span class="p">;</span>  <span class="c1">// first stage </span>
    <span class="kt">logic</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">stage2_l</span><span class="p">;</span>  <span class="c1">// second stage </span>

    <span class="c1">// two sequential flip-flops</span>
    <span class="k">always_ff</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clk_dest</span><span class="p">)</span> <span class="k">begin</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rst_dest_i</span><span class="p">)</span> <span class="k">begin</span>
            <span class="n">stage1_l</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
            <span class="n">stage2_l</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>           
        <span class="k">end</span>
        <span class="k">else</span> <span class="k">begin</span>
            <span class="n">stage1_l</span> <span class="o">&lt;=</span> <span class="n">async_signal_i</span><span class="p">;</span>
            <span class="n">stage2_l</span> <span class="o">&lt;=</span> <span class="n">stage1_l</span><span class="p">;</span>
        <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">assign</span> <span class="n">sync_signal_o</span> <span class="o">=</span> <span class="n">stage2_l</span><span class="p">;</span>

<span class="k">endmodule</span>
</code></pre></div></div>

<h4 id="binary-and-gray-encoding">Binary and Gray Encoding</h4>

<p>Transferring a data bus is more challenging as binary encoding is unsafe due to the possibility of multiple bits changing in one increment or decrement. This may cause data corruption from some bits updating on the first destination clock synchronizer while other bits remain in their previous state. This is a massive problem for digital design, for example, think about a state machine encoding. If state changes and is passed to the destination clock, corrupted bits may cause the state encoding to point to a nonexistent state.</p>

<p>Instead, Gray code is used because only one bit changes per increment or decrement, making it safer for synchronization as it will either stay in the form of the previous data or update to the correct current data.</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="n">bin_to_gray</span>
  <span class="p">#(</span><span class="k">parameter</span> <span class="n">width_p</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
  <span class="p">(</span><span class="kt">input</span> <span class="p">[</span><span class="n">width_p</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">bin_i</span>
  <span class="p">,</span><span class="kt">output</span> <span class="p">[</span><span class="n">width_p</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">gray_o</span><span class="p">);</span>

   <span class="k">genvar</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">generate</span>
      <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">width_p</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">begin</span>
        <span class="k">assign</span> <span class="n">gray_o</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">bin_i</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
      <span class="k">end</span>
    <span class="k">endgenerate</span>

    <span class="k">assign</span> <span class="n">gray_o</span><span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_i</span><span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>

<span class="k">endmodule</span>
</code></pre></div></div>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="n">gray_to_bin</span>
  <span class="p">#(</span><span class="k">parameter</span> <span class="n">width_p</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
   <span class="p">(</span><span class="kt">input</span> <span class="p">[</span><span class="n">width_p</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">gray_i</span>
    <span class="p">,</span><span class="kt">output</span> <span class="p">[</span><span class="n">width_p</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">bin_o</span><span class="p">);</span>

  <span class="k">genvar</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">generate</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">width_p</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
      <span class="k">assign</span> <span class="n">bin_o</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">gray_i</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">);</span>
    <span class="k">end</span>
  <span class="k">endgenerate</span>

<span class="k">endmodule</span>
</code></pre></div></div>
<h2 id="pulse-stretching">Pulse Stretching</h2>

<p>When transferring signals from a fast clock domain to a slow clock domain, the primary challenge is ensuring that the signal remains active long enough for the slow clock to reliably sample it. Without proper handling, a short-lived pulse in the fast domain might be missed entirely in the slow domain. This section explains how to address this issue using pulse stretching and provides practical guidelines for implementation.</p>

<p>Consider a scenario where:</p>

<ul>
  <li>Fast Clock (CLK_FAST): 100 MHz (10 ns period).</li>
  <li>Slow Clock (CLK_SLOW): 25 MHz (40 ns period).</li>
</ul>

<p>If a pulse in the fast domain lasts only 1 clock cycle (10 ns), it might not align with the rising edge of the slow clock, or it might violate setup/hold requirements. As a result, the slow domain could miss the pulse entirely.</p>

<p>To ensure the slow domain reliably detects the pulse, the signal must be stretched in the fast domain. The goal is to make the pulse active for at least 2 clock cycles of the slow domain (80 ns in this example).</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="n">fast_to_slow_sync</span> <span class="p">(</span>
    <span class="kt">input</span>  <span class="n">clk_fast</span><span class="p">,</span>
    <span class="kt">input</span>  <span class="n">rst_fast</span><span class="p">,</span>
    <span class="kt">input</span>  <span class="n">clk_slow</span><span class="p">,</span>
    <span class="kt">input</span>  <span class="n">rst_slow</span><span class="p">,</span>
    <span class="kt">input</span>  <span class="n">pulse_fast_i</span><span class="p">,</span>
    <span class="kt">output</span> <span class="n">pulse_slow_o</span>
<span class="p">);</span>
    <span class="kt">logic</span> <span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">stretch_ff</span><span class="p">;</span>
    <span class="kt">logic</span> <span class="n">stretched_pulse</span><span class="p">;</span>
    <span class="kt">logic</span> <span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">sync_ff</span><span class="p">;</span>

    <span class="k">always_ff</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clk_fast</span><span class="p">)</span> <span class="k">begin</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rst_fast</span><span class="p">)</span> <span class="n">stretch_ff</span> <span class="o">&lt;=</span> <span class="mb">8'b00000000</span><span class="p">;</span>
        <span class="k">else</span>          <span class="n">stretch_ff</span> <span class="o">&lt;=</span> <span class="o">{</span><span class="n">stretch_ff</span><span class="p">[</span><span class="mi">6</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span> <span class="n">pulse_fast_i</span><span class="o">}</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="k">assign</span> <span class="n">stretched_pulse</span> <span class="o">=</span> <span class="o">|</span><span class="n">stretch_ff</span><span class="p">;</span>

    <span class="k">always_ff</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clk_slow</span><span class="p">)</span> <span class="k">begin</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rst_slow</span><span class="p">)</span> <span class="n">sync_ff</span> <span class="o">&lt;=</span> <span class="mb">2'b00</span><span class="p">;</span>
        <span class="k">else</span>          <span class="n">sync_ff</span> <span class="o">&lt;=</span> <span class="o">{</span><span class="n">sync_ff</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stretched_pulse</span><span class="o">}</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="k">assign</span> <span class="n">pulse_slow_o</span> <span class="o">=</span> <span class="n">sync_ff</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

<span class="k">endmodule</span>
</code></pre></div></div>

<h2 id="fifo-example">FIFO Example</h2>

<p>With the previous tools, we can implement a CDC fifo that is capable of transfering bulk data without the threat of data corruption issues. In order to create the CDC FIFO, we must initialize a RAM interface that will read data synchronized to the producer clock and write data synchronized to the consumer clock.</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="n">ram_1r1w_sync</span>
  <span class="p">#(</span><span class="k">parameter</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">width_p</span> <span class="o">=</span> <span class="mi">8</span>
  <span class="p">,</span><span class="k">parameter</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">depth_p</span> <span class="o">=</span> <span class="mi">512</span>
  <span class="p">,</span><span class="k">parameter</span> <span class="kt">string</span> <span class="n">filename_p</span> <span class="o">=</span> <span class="s">"memory_init_file.bin"</span><span class="p">)</span>
  <span class="p">(</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">pclk_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">cclk_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">preset_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">creset_i</span>

  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">wr_valid_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">wr_data_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">depth_p</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">wr_addr_i</span>

  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">rd_valid_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">depth_p</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">rd_addr_i</span>
  <span class="p">,</span><span class="kt">output</span> <span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">rd_data_o</span><span class="p">);</span>
   <span class="kt">logic</span> <span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">ram</span> <span class="p">[</span><span class="n">depth_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>

   <span class="k">initial</span> <span class="k">begin</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">depth_p</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
        <span class="n">ram</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mb">'0</span><span class="p">;</span>
      <span class="k">end</span>
   <span class="k">end</span>

   <span class="kt">logic</span> <span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">rd_data_l</span><span class="p">;</span>

   <span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">pclk_i</span><span class="p">)</span> <span class="k">begin</span>
      <span class="k">if</span><span class="p">(</span><span class="n">preset_i</span><span class="p">)</span> <span class="k">begin</span>
         <span class="n">rd_data_l</span> <span class="o">&lt;=</span> <span class="mb">'0</span><span class="p">;</span>
      <span class="k">end</span> 
      <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rd_valid_i</span><span class="p">)</span> <span class="k">begin</span>
          <span class="n">rd_data_l</span> <span class="o">&lt;=</span> <span class="n">ram</span><span class="p">[</span><span class="n">rd_addr_i</span><span class="p">];</span>
      <span class="k">end</span>
   <span class="k">end</span>

   <span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">cclk_i</span><span class="p">)</span> <span class="k">begin</span>
      <span class="k">if</span><span class="p">(</span><span class="n">creset_i</span><span class="p">)</span> <span class="k">begin</span>
         <span class="n">ram</span><span class="p">[</span><span class="n">wr_addr_i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ram</span><span class="p">[</span><span class="n">wr_addr_i</span><span class="p">];</span>
      <span class="k">end</span> 
      <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">wr_valid_i</span><span class="p">)</span> <span class="k">begin</span>
          <span class="n">ram</span><span class="p">[</span><span class="n">wr_addr_i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">wr_data_i</span><span class="p">;</span>
      <span class="k">end</span>
   <span class="k">end</span>

   <span class="k">assign</span> <span class="n">rd_data_o</span> <span class="o">=</span> <span class="n">rd_data_l</span><span class="p">;</span>

<span class="k">endmodule</span>
</code></pre></div></div>

<p>Now we implement the CDC FIFO by connecting the synchronizers, gray encoding, and the two clock port RAM module. We use the RAM module to transfer data between the two clock domains safely. Within the FIFO implementation, the read and write addresses must be transferred between clock domains in order to facilitate the logic for the ready valid handshakes between interfaces.</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="n">fifo_1r1w_cdc</span>
 <span class="p">#(</span><span class="k">parameter</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">width_p</span> <span class="o">=</span> <span class="mi">32</span>
  <span class="p">,</span><span class="k">parameter</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">depth_log2_p</span> <span class="o">=</span> <span class="mi">8</span>
  <span class="p">)</span>
   <span class="c1">// the "c" for consumer, and "p" for producer interfaces. </span>
  <span class="p">(</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">cclk_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">creset_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">cdata_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">cvalid_i</span>
  <span class="p">,</span><span class="kt">output</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">cready_o</span> 

  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">pclk_i</span>
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">preset_i</span>
  <span class="p">,</span><span class="kt">output</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">pvalid_o</span> 
  <span class="p">,</span><span class="kt">output</span> <span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">pdata_o</span> 
  <span class="p">,</span><span class="kt">input</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">pready_i</span>
  <span class="p">);</span>

    <span class="kt">wire</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">full</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">empty</span><span class="p">;</span>
   
    <span class="kt">wire</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">en_w</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">en_r</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="p">[</span><span class="n">width_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">ram_o</span><span class="p">;</span>

    <span class="kt">logic</span> <span class="p">[</span><span class="n">depth_log2_p</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">wr_add</span><span class="p">,</span> <span class="n">wr_add_delay</span><span class="p">,</span> 
    <span class="n">wr_add_bin2gray</span><span class="p">,</span> <span class="n">wr_add_sync1</span><span class="p">,</span> <span class="n">wr_add_sync2</span><span class="p">,</span> 
    <span class="n">crossed_wr_add</span><span class="p">,</span> <span class="n">rd_add</span><span class="p">,</span> <span class="n">rd_add_delay</span><span class="p">,</span> 
    <span class="n">rd_add_bin2gray</span><span class="p">,</span> <span class="n">rd_add_sync1</span><span class="p">,</span> <span class="n">rd_add_sync2</span><span class="p">,</span> 
    <span class="n">crossed_rd_add</span><span class="p">,</span> <span class="n">rd_add_next</span><span class="p">;</span>

    <span class="k">assign</span> <span class="n">en_w</span> <span class="o">=</span> <span class="n">cvalid_i</span> <span class="o">&amp;&amp;</span> <span class="n">cready_o</span><span class="p">;</span>
    <span class="k">assign</span> <span class="n">en_r</span> <span class="o">=</span> <span class="n">pready_i</span> <span class="o">&amp;&amp;</span> <span class="n">pvalid_o</span><span class="p">;</span>

    <span class="k">assign</span> <span class="n">full</span> <span class="o">=</span><span class="p">(</span><span class="n">wr_add</span><span class="p">[</span><span class="n">depth_log2_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> 
        <span class="n">crossed_rd_add</span><span class="p">[</span><span class="n">depth_log2_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;&amp;</span> 
        <span class="p">(</span><span class="n">wr_add</span><span class="p">[</span><span class="n">depth_log2_p</span><span class="p">]</span> <span class="o">!==</span> 
        <span class="n">crossed_rd_add</span><span class="p">[</span><span class="n">depth_log2_p</span><span class="p">]);</span>
    <span class="k">assign</span> <span class="n">empty</span> <span class="o">=</span> <span class="p">(</span><span class="n">crossed_wr_add</span> <span class="o">===</span> <span class="n">rd_add</span><span class="p">);</span>
    <span class="k">assign</span> <span class="n">cready_o</span> <span class="o">=</span> <span class="o">~</span><span class="n">full</span><span class="p">;</span>
    <span class="k">assign</span> <span class="n">pvalid_o</span> <span class="o">=</span> <span class="o">~</span><span class="n">empty</span><span class="p">;</span>

  <span class="c1">// cross for wr_add from consumer to producer side</span>
  <span class="c1">// convert the write address to gray encoding</span>
  <span class="n">bin2gray</span>
  <span class="p">#(.</span><span class="n">width_p</span><span class="p">(</span><span class="n">depth_log2_p</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
  <span class="n">bin2gray_inst_wr_add</span>
  <span class="p">(.</span><span class="n">bin_i</span><span class="p">(</span><span class="n">wr_add</span><span class="p">)</span>
  <span class="p">,.</span><span class="n">gray_o</span><span class="p">(</span><span class="n">wr_add_bin2gray</span><span class="p">));</span>

  <span class="c1">//delay the grey encoded write address for 1 cc</span>
  <span class="k">always_ff</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">cclk_i</span><span class="p">)</span> <span class="k">begin</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">creset_i</span><span class="p">)</span> <span class="k">begin</span>
      <span class="n">wr_add_delay</span> <span class="o">&lt;=</span> <span class="mb">'0</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="k">else</span> <span class="k">begin</span>
      <span class="n">wr_add_delay</span> <span class="o">&lt;=</span> <span class="n">wr_add_bin2gray</span><span class="p">;</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1">// two stages of synchronizers</span>
  <span class="k">always_ff</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">pclk_i</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="n">preset_i</span><span class="p">)</span> <span class="k">begin</span> 
      <span class="n">wr_add_sync1</span> <span class="o">&lt;=</span> <span class="mb">'0</span><span class="p">;</span> 
      <span class="n">wr_add_sync2</span> <span class="o">&lt;=</span> <span class="mb">'0</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="k">else</span> <span class="k">begin</span> 
      <span class="n">wr_add_sync1</span> <span class="o">&lt;=</span> <span class="n">wr_add_delay</span><span class="p">;</span>
      <span class="n">wr_add_sync2</span> <span class="o">&lt;=</span> <span class="n">wr_add_sync1</span><span class="p">;</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1">// convert write address to bin encoding</span>
  <span class="n">gray2bin</span>
  <span class="p">#(.</span><span class="n">width_p</span><span class="p">(</span><span class="n">depth_log2_p</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">gray2bin_inst_wr_add</span>
   <span class="p">(.</span><span class="n">gray_i</span><span class="p">(</span><span class="n">wr_add_sync2</span><span class="p">)</span>
    <span class="p">,.</span><span class="n">bin_o</span><span class="p">(</span><span class="n">crossed_wr_add</span><span class="p">));</span>  

  <span class="c1">// cross for rd_add from producer to consumer side</span>
  <span class="c1">// convert to gray encoding</span>
  <span class="n">bin_to_gray</span>
  <span class="p">#(.</span><span class="n">width_p</span><span class="p">(</span><span class="n">depth_log2_p</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
  <span class="n">bin2gray_inst_rd_add</span>
  <span class="p">(.</span><span class="n">bin_i</span><span class="p">(</span><span class="n">rd_add</span><span class="p">)</span>
  <span class="p">,.</span><span class="n">gray_o</span><span class="p">(</span><span class="n">rd_add_bin2gray</span><span class="p">));</span>

  <span class="c1">// two stages of synchronizers</span>
  <span class="k">always_ff</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">cclk_i</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="n">creset_i</span><span class="p">)</span> <span class="k">begin</span> 
      <span class="n">rd_add_sync1</span> <span class="o">&lt;=</span> <span class="mb">'0</span><span class="p">;</span> 
      <span class="n">rd_add_sync2</span> <span class="o">&lt;=</span> <span class="mb">'0</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="k">else</span> <span class="k">begin</span> 
      <span class="n">rd_add_sync1</span> <span class="o">&lt;=</span> <span class="n">rd_add_bin2gray</span><span class="p">;</span>
      <span class="n">rd_add_sync2</span> <span class="o">&lt;=</span> <span class="n">rd_add_sync1</span><span class="p">;</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1">// convert back to bin encoding</span>
  <span class="n">gray_to_bin</span>
  <span class="p">#(.</span><span class="n">width_p</span><span class="p">(</span><span class="n">depth_log2_p</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">gray2bin_inst_rd_add</span>
   <span class="p">(.</span><span class="n">gray_i</span><span class="p">(</span><span class="n">rd_add_sync2</span><span class="p">)</span>
    <span class="p">,.</span><span class="n">bin_o</span><span class="p">(</span><span class="n">crossed_rd_add</span><span class="p">));</span>  

  <span class="k">always_ff</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">cclk_i</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="n">creset_i</span><span class="p">)</span> <span class="k">begin</span> 
      <span class="n">wr_add</span> <span class="o">&lt;=</span> <span class="mb">'0</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">en_w</span><span class="p">)</span> <span class="k">begin</span>
      <span class="n">wr_add</span> <span class="o">&lt;=</span> <span class="n">wr_add</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">always_ff</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">pclk_i</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">preset_i</span><span class="p">)</span> <span class="k">begin</span>
      <span class="n">rd_add</span> <span class="o">&lt;=</span> <span class="mb">'0</span><span class="p">;</span>
    <span class="k">end</span> 
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">en_r</span><span class="p">)</span> <span class="k">begin</span>
      <span class="n">rd_add</span> <span class="o">&lt;=</span> <span class="n">rd_add</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">always_comb</span> <span class="k">begin</span> 
    <span class="n">rd_add_next</span> <span class="o">=</span> <span class="n">rd_add</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">en_r</span><span class="p">)</span> <span class="k">begin</span>
      <span class="n">rd_add_next</span> <span class="o">=</span> <span class="n">rd_add</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">ram_1r1w_sync</span>
  <span class="p">#(.</span><span class="n">width_p</span><span class="p">(</span><span class="n">width_p</span><span class="p">),</span> 
    <span class="p">.</span><span class="n">depth_p</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">depth_log2_p</span><span class="p">),</span> 
    <span class="p">.</span><span class="n">filename_p</span><span class="p">())</span> 
    <span class="n">ram_1r1w_sync_inst</span>
   <span class="p">(.</span><span class="n">pclk_i</span><span class="p">(</span><span class="n">pclk_i</span><span class="p">),</span> 
   <span class="p">.</span><span class="n">cclk_i</span><span class="p">(</span><span class="n">cclk_i</span><span class="p">),</span> 
    <span class="p">.</span><span class="n">preset_i</span><span class="p">(</span><span class="n">preset_i</span><span class="p">),</span>
    <span class="p">.</span><span class="n">creset_i</span><span class="p">(</span><span class="n">creset_i</span><span class="p">),</span>
    <span class="p">.</span><span class="n">wr_valid_i</span><span class="p">(</span><span class="n">en_w</span><span class="p">),</span>
    <span class="p">.</span><span class="n">wr_data_i</span><span class="p">(</span><span class="n">cdata_i</span><span class="p">),</span>
    <span class="p">.</span><span class="n">wr_addr_i</span><span class="p">(</span><span class="n">wr_add</span><span class="p">[</span><span class="n">depth_log2_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]),</span>
    <span class="p">.</span><span class="n">rd_valid_i</span><span class="p">(</span><span class="mb">1'b1</span><span class="p">),</span>
    <span class="p">.</span><span class="n">rd_addr_i</span><span class="p">(</span><span class="n">rd_add_next</span><span class="p">[</span><span class="n">depth_log2_p</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]),</span> 
    <span class="p">.</span><span class="n">rd_data_o</span><span class="p">(</span><span class="n">pdata_o</span><span class="p">));</span>

<span class="k">endmodule</span>
</code></pre></div></div>]]></content><author><name>Annabella</name></author><category term="concepts" /><category term="jekyll" /><category term="minimal-mistakes" /><summary type="html"><![CDATA[What is Clock Domain Crossing? Solutions Flip-Flop Synchronizers Binary and Gray Encoding Pulse Stretching FIFO Example What is Clock Domain Crossing? Clock Domain Crossing (CDC) occurs when data transfers between different clock domains that may differ in frequency or phase. In a multi-clock system, data is first updated synchronously with the edge of the source clock, then it must be safely captured and updated synchronously in the destination clock domain. While simple in theory, there are challenging aspects to consider when attempting to maintain the reliability of data transfer. Signals that originate from one clock domain may not meet the setup and hold time required by the destination clock. Incorrect handling of CDC will lead to timing violations, metastability, data corruption, and other unpredictable behaviors in digital systems. Though timing issues are a concern when implementing CDC, there are many performance benefits to using multiple clock domains in a digital design. Decrease the clock rate for some parts of the design while using a higher clock rate when necessary in order to improve power efficiency. Data throughput can be improved for a high-speed communication protocol while internal interactions operate at a lower clock rate. There is more design flexibility when utilizing multiple clocks in a single design. Improves clock tree synthesis results for skew and jitter when there are multiple localized clocks rather than one global clock. Clock Domain Crossing Solutions To achieve reliable data transfer, various CDC techniques are used. Some strategies include flip-flop synchronizers, handshake protocols, and FIFO-based solutions. FIFO buffers are particularly useful when handling bulk data transfers across clock domains, which we will explore in detail. Flip-Flop Synchronizers Among the most simple ways to solve CDC timing issues is through a flip-flop synchronizer. This uses (usually) two sequential flip-flops triggered by the destination clock. The flip-flop synchronizer solution will allow enough time for a signal to settle and avoid metastability. module ff_synchronizer ( input [0:0] clk_dest_i, // destination clock input [0:0] rst_dest_i, // destination reset input [0:0] async_signal_i, // async input signal output [0:0] sync_signal_o // sync output signal ); logic [0:0] stage1_l; // first stage logic [0:0] stage2_l; // second stage // two sequential flip-flops always_ff @(posedge clk_dest) begin if (rst_dest_i) begin stage1_l &lt;= 1'b0; stage2_l &lt;= 1'b0; end else begin stage1_l &lt;= async_signal_i; stage2_l &lt;= stage1_l; end end assign sync_signal_o = stage2_l; endmodule Binary and Gray Encoding Transferring a data bus is more challenging as binary encoding is unsafe due to the possibility of multiple bits changing in one increment or decrement. This may cause data corruption from some bits updating on the first destination clock synchronizer while other bits remain in their previous state. This is a massive problem for digital design, for example, think about a state machine encoding. If state changes and is passed to the destination clock, corrupted bits may cause the state encoding to point to a nonexistent state. Instead, Gray code is used because only one bit changes per increment or decrement, making it safer for synchronization as it will either stay in the form of the previous data or update to the correct current data. module bin_to_gray #(parameter width_p = 5) (input [width_p - 1 : 0] bin_i ,output [width_p - 1 : 0] gray_o); genvar i; generate for(i = width_p -1; i &gt; 0; i = i - 1) begin assign gray_o[i - 1] = bin_i[i] ^ bin_i[i - 1]; end endgenerate assign gray_o[width_p-1] = bin_i[width_p-1]; endmodule module gray_to_bin #(parameter width_p = 5) (input [width_p - 1 : 0] gray_i ,output [width_p - 1 : 0] bin_o); genvar i; generate for(i = 0; i &lt; width_p; i++) begin assign bin_o[i] = ^(gray_i &gt;&gt; i); end endgenerate endmodule Pulse Stretching When transferring signals from a fast clock domain to a slow clock domain, the primary challenge is ensuring that the signal remains active long enough for the slow clock to reliably sample it. Without proper handling, a short-lived pulse in the fast domain might be missed entirely in the slow domain. This section explains how to address this issue using pulse stretching and provides practical guidelines for implementation. Consider a scenario where: Fast Clock (CLK_FAST): 100 MHz (10 ns period). Slow Clock (CLK_SLOW): 25 MHz (40 ns period). If a pulse in the fast domain lasts only 1 clock cycle (10 ns), it might not align with the rising edge of the slow clock, or it might violate setup/hold requirements. As a result, the slow domain could miss the pulse entirely. To ensure the slow domain reliably detects the pulse, the signal must be stretched in the fast domain. The goal is to make the pulse active for at least 2 clock cycles of the slow domain (80 ns in this example). module fast_to_slow_sync ( input clk_fast, input rst_fast, input clk_slow, input rst_slow, input pulse_fast_i, output pulse_slow_o ); logic [7:0] stretch_ff; logic stretched_pulse; logic [1:0] sync_ff; always_ff @(posedge clk_fast) begin if (rst_fast) stretch_ff &lt;= 8'b00000000; else stretch_ff &lt;= {stretch_ff[6:0], pulse_fast_i}; end assign stretched_pulse = |stretch_ff; always_ff @(posedge clk_slow) begin if (rst_slow) sync_ff &lt;= 2'b00; else sync_ff &lt;= {sync_ff[0], stretched_pulse}; end assign pulse_slow_o = sync_ff[1]; endmodule FIFO Example With the previous tools, we can implement a CDC fifo that is capable of transfering bulk data without the threat of data corruption issues. In order to create the CDC FIFO, we must initialize a RAM interface that will read data synchronized to the producer clock and write data synchronized to the consumer clock. module ram_1r1w_sync #(parameter [31:0] width_p = 8 ,parameter [31:0] depth_p = 512 ,parameter string filename_p = "memory_init_file.bin") (input [0:0] pclk_i ,input [0:0] cclk_i ,input [0:0] preset_i ,input [0:0] creset_i ,input [0:0] wr_valid_i ,input [width_p-1:0] wr_data_i ,input [$clog2(depth_p) - 1 : 0] wr_addr_i ,input [0:0] rd_valid_i ,input [$clog2(depth_p) - 1 : 0] rd_addr_i ,output [width_p-1:0] rd_data_o); logic [width_p-1:0] ram [depth_p-1:0]; initial begin for (int i = 0; i &lt; depth_p; i++) begin ram[i] = '0; end end logic [width_p-1:0] rd_data_l; always @(posedge pclk_i) begin if(preset_i) begin rd_data_l &lt;= '0; end else if(rd_valid_i) begin rd_data_l &lt;= ram[rd_addr_i]; end end always @(posedge cclk_i) begin if(creset_i) begin ram[wr_addr_i] &lt;= ram[wr_addr_i]; end else if(wr_valid_i) begin ram[wr_addr_i] &lt;= wr_data_i; end end assign rd_data_o = rd_data_l; endmodule Now we implement the CDC FIFO by connecting the synchronizers, gray encoding, and the two clock port RAM module. We use the RAM module to transfer data between the two clock domains safely. Within the FIFO implementation, the read and write addresses must be transferred between clock domains in order to facilitate the logic for the ready valid handshakes between interfaces. module fifo_1r1w_cdc #(parameter [31:0] width_p = 32 ,parameter [31:0] depth_log2_p = 8 ) // the "c" for consumer, and "p" for producer interfaces. (input [0:0] cclk_i ,input [0:0] creset_i ,input [width_p-1:0] cdata_i ,input [0:0] cvalid_i ,output [0:0] cready_o ,input [0:0] pclk_i ,input [0:0] preset_i ,output [0:0] pvalid_o ,output [width_p-1:0] pdata_o ,input [0:0] pready_i ); wire [0:0] full; wire [0:0] empty; wire [0:0] en_w; wire [0:0] en_r; wire [width_p-1:0] ram_o; logic [depth_log2_p:0] wr_add, wr_add_delay, wr_add_bin2gray, wr_add_sync1, wr_add_sync2, crossed_wr_add, rd_add, rd_add_delay, rd_add_bin2gray, rd_add_sync1, rd_add_sync2, crossed_rd_add, rd_add_next; assign en_w = cvalid_i &amp;&amp; cready_o; assign en_r = pready_i &amp;&amp; pvalid_o; assign full =(wr_add[depth_log2_p-1:0] === crossed_rd_add[depth_log2_p-1:0]) &amp;&amp; (wr_add[depth_log2_p] !== crossed_rd_add[depth_log2_p]); assign empty = (crossed_wr_add === rd_add); assign cready_o = ~full; assign pvalid_o = ~empty; // cross for wr_add from consumer to producer side // convert the write address to gray encoding bin2gray #(.width_p(depth_log2_p+1)) bin2gray_inst_wr_add (.bin_i(wr_add) ,.gray_o(wr_add_bin2gray)); //delay the grey encoded write address for 1 cc always_ff @(posedge cclk_i) begin if (creset_i) begin wr_add_delay &lt;= '0; end else begin wr_add_delay &lt;= wr_add_bin2gray; end end // two stages of synchronizers always_ff @(posedge pclk_i) begin if(preset_i) begin wr_add_sync1 &lt;= '0; wr_add_sync2 &lt;= '0; end else begin wr_add_sync1 &lt;= wr_add_delay; wr_add_sync2 &lt;= wr_add_sync1; end end // convert write address to bin encoding gray2bin #(.width_p(depth_log2_p+1)) gray2bin_inst_wr_add (.gray_i(wr_add_sync2) ,.bin_o(crossed_wr_add)); // cross for rd_add from producer to consumer side // convert to gray encoding bin_to_gray #(.width_p(depth_log2_p+1)) bin2gray_inst_rd_add (.bin_i(rd_add) ,.gray_o(rd_add_bin2gray)); // two stages of synchronizers always_ff @(posedge cclk_i) begin if(creset_i) begin rd_add_sync1 &lt;= '0; rd_add_sync2 &lt;= '0; end else begin rd_add_sync1 &lt;= rd_add_bin2gray; rd_add_sync2 &lt;= rd_add_sync1; end end // convert back to bin encoding gray_to_bin #(.width_p(depth_log2_p+1)) gray2bin_inst_rd_add (.gray_i(rd_add_sync2) ,.bin_o(crossed_rd_add)); always_ff @(posedge cclk_i) begin if(creset_i) begin wr_add &lt;= '0; end else if (en_w) begin wr_add &lt;= wr_add + 1; end end always_ff @(posedge pclk_i) begin if (preset_i) begin rd_add &lt;= '0; end else if (en_r) begin rd_add &lt;= rd_add + 1; end end always_comb begin rd_add_next = rd_add; if(en_r) begin rd_add_next = rd_add + 1; end end ram_1r1w_sync #(.width_p(width_p), .depth_p(1&lt;&lt;depth_log2_p), .filename_p()) ram_1r1w_sync_inst (.pclk_i(pclk_i), .cclk_i(cclk_i), .preset_i(preset_i), .creset_i(creset_i), .wr_valid_i(en_w), .wr_data_i(cdata_i), .wr_addr_i(wr_add[depth_log2_p-1:0]), .rd_valid_i(1'b1), .rd_addr_i(rd_add_next[depth_log2_p-1:0]), .rd_data_o(pdata_o)); endmodule]]></summary></entry></feed>